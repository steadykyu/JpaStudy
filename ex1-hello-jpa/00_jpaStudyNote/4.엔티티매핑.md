# 엔티티매핑
## 1. 객체와 테이블 매핑
### @Entitiy
+ @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. 
```
주의 
 - 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) - 추후 나올 기술들을 위해서
 - final 클래스, enum, interface, inner 클래스 사용X 
 - 저장할 필드에 final 사용 X
 ```
 + 속성: name - @Entitiy(name="")
 + JPA에서 사용할 **엔티티이름을** 지정한다.
 + 기본 값으로 클래스 이름을 그대로 사용한다.(가급적 기본값)

### @Table
+ @Table은 엔티티와 **매핑할 테이블** 지정
```
아래 4가지 기준으로 매핑한 테이블을 구분짓고 가져올수 있다.
1. name 
2. category
3. schema
4. uniqueConstraints
```
### 사용코드
```java
@Entity
//@Table(name = "USER")
public class Member {.....}
```
## 2. 데이터 베이스 스키마 자동 생성
```
 - DDL을 애플리케이션 실행 시점에 자동 생성
 - 테이블 중심 -> 객체 중심
 - 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
 - 이렇게 생성된 DDL은 개발 장비에서만 사용
 - 생성된 DDL은 운영서버에서는 거의 사용하지 않음. 적절히 다듬은 후 사용
```
### 속성들
persistence.xml 의 
```
<property name="hibernate.hbm2ddl.auto" value="create" />
```
+ value 값에 따라 달라진다.
```
1.create : 기존테이블 삭제 후 엔티티에 맞춰 다시 생성 (DROP + CREATE)
2.create-drop: create와 같으나 종료시점에 테이블 DROP
3.update : 기존 DB는 유지한채, 값이 수정되거나 추가된 변경분만 반영
    - 값이 제거되는 변경은 일어나지 않는다.(데이터 손실 리스크 방지)
    - 운영DB에는 사용하면 안됨
4.validate 엔티티와 테이블이 정상 매핑되었는지만 확인
5.none : 아무 옵션도 사용하지 않음
```
### 실습
> create의 소스 코드 결과값

```
Hibernate: 
    
    drop table Member if exists
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )
```
> 방언을 오라클로 수정시

```
Hibernate: 
    
    drop table Member cascade constraints
Hibernate: 
    
    create table Member (
       id number(19,0) not null,
        name varchar2(255 char),
        primary key (id)
    )
```
+ Table 기본 char column이 varchar2로 수정된 것을 볼 수 있다.
> Update option 및 엔티티에 age column 추가.
```
Hibernate: 
    
    alter table Member 
       add column age integer not null
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.age as age2_0_0_,
        member0_.name as name3_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
```
+ alter 쿼리가 추가됨.

### 주의 
+ 운영 장비에는 **절대 create, create-drop, update 사용하면 안된다.**
```
• 개발 초기 단계는 create 또는 update 
• 테스트 서버는 update 또는 validate 
    - 만약 create하면 서버가 날라가는 문제가 발생한다.
• 스테이징과 운영 서버는 validate 또는 none
    - 몇천만건의 데이터에서 데이터를 수정하거나 없얘면 시스템이 멈출 위험이 크다.
```
+ 운영서버는 왠만하면 꼼꼼하게 직접 개발하거나 쿼리를 수정해서 넣거나 dba에게 주는식으로 해야한다.

### DDL 생성 기능
+ DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다. (런타임에러 발생 X)
+ 다만 DB에는 영향에만 영향을 주는 것이다. 
```
• 제약조건 추가: 회원 이름은 필수, 10자 초과X , unique 값이야
• @Column(nullable = false, length = 10, unique = true)
```

## 3. 필드와 컬럼 매핑
> 요구 사항을 추가해보자.
```
1. 회원은 일반 회원과 관리자로 구분해야 한다. 
2. 회원 가입일과 수정일이 있어야 한다. 
3. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.
```
### 매핑 어노테이션 정리
> 필드값 추가
```
public class Member {
    @Id
    private Long id;
    @Column(name = "name")
    private String username;
    private Integer age;
    @Enumerated(EnumType.STRING)
    private RoleType roleType;
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
    private LocalDate testLocalDate;
    private LocalDateTime testLocalDateTime;
    @Lob
    private String description;

    public Member(){

    }

}
```
그림 1
+ @Lob : varchar보다 더 큰 범위의 String
### @Column
+ 그림2
> insertable, updatable
```
@Column(name = "name", insertable = false, updatable = false)
    private String username;
```
+ 위와같은 방식으로 작성하며, 위는 등록도 수정도 할수 없다.(강제로 DB에서만 가능)
```java
@Entity
@Table(uniqueConstraints={@UniqueConstraint(columnNames={"username"})})
public class Member {...}
```
+ unique는 이름 반영이 이상한 값으로 되기때문에 여기서 쓰지 않는다
+ @Table에서 필드값에 unique 조건을 줄 수 있다.

### @Enumerated
그림3
+ original시 integer로 들어간다. Enum 값에 맞추어 0, 1, 2, 3 순서로 고정적으로 들어간다.
+ ex) USER, ADMIN -> 0 , 1
+ 여기서 갑자기 값이 추가되면, 순서값으로 들어가기 때문에 문제가 발생할 수 있다.
+ ex) MIDDLE,USER, ADMIN -> 0 , 1, 2   : 이미 DB에는 USER, ADMIN이 0,1로 들어가있는데 0,1,2 순서에 맞게 값을 넣어 문제 발생.
+ 디폴트가 ORDINAL 이므로, 꼭 STRING으로 바꿔주자.

### @Temporal
+ 자바 8이전에는 필요했지만 이후로는 
+ LocalDate(연월데이터), LocalDateTime(연월데이터시간) 으로 매핑이 되므로, 이전 자바에서 만들어진 웹에서만 쓰자.

### @Lob
+ 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
+ @Lob에는 지정할 수 있는 속성이 없다.

### @Transient
필드 매핑X 
+ 데이터베이스에 저장X, 조회X 
+ 주로 메모리상에서만 **임시로** 어떤 값을 보관하고 싶을 때 사용
```
@Transient
private Integer temp;
```

## 4. 기본 키 매핑

### 기본 키 매핑 방법
+ 직접 할당: @Id만 사용
+ 자동 생성(@GeneratedValue) 
```
• TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator 필요
• 계속 정책이 바뀌고 있어서, 그떄그때 확인해보는 것이 좋다.
```
### 직접할당
```
 @Id
 private Long id;
...
```
+ 엔티티에서 id 값을 직접 넣어주어야 한다.
```
Member member = new Member();
member.setId(1L);
```

### 자동생성
``` java
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
```
+ 방언에 따라 자동 지정, 기본값이다.

#### IDENTITY 전략
```
 @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
```
> 출력결과
```
Hibernate: 
    
    drop table Member if exists
Hibernate: 
    
    create table Member (
       id bigint generated by default as identity,
        name varchar(255) not null,
        primary key (id)
    )
```
> 특징
```
• 기본 키 생성을 데이터베이스에 위임(1,2,3 순서로 넣어줌)
• 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(예: MySQL의 AUTO_ INCREMENT) 
• JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행하지만, AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음.
• 즉 엔티티와 영속성 컨테이너 를 작동시키기 위해서, 억지로 JPA가 em.persist() 시점에 DB쪽으로 insert 쿼리를 자동으로 날린다.
• 영속성 컨테이너의 버퍼링기능을 사용하지 못하게 된다.(근데 버퍼링으로 인한 성능차이가 크게 유의하지 않아서 괜찮음)
```

#### sequence 전략
+ SEQUENCE: 데이터베이스 시퀀스 는 유일한 값을 순서대로 생성하는 오브젝트 사용(ex: ORACLE 주로사용 )
+ sequence 객체에서 값을 가져오며, sequence는 문자면 안된다.(Long 쓰는것이 좋음)
```java
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ", // 매핑할 데이터베이스 시퀀스 이름
        initialValue = 1, allocationSize = 50)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR") //@SequenceGenerator name 과 일치
    private Long id;
```
> 결과값
```java
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 50
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255) not null,
        primary key (id)
    )
Hibernate: 
    call next value for MEMBER_SEQ
```
+ 그림4
+ 만약 Table마다 sequence를 따로 관리하고 싶다면 @SequenceGenerator로 설정 해줄 수 있다.
```
sequenceName으로 여러 sequence생성하고 관리가 가능하다.
```
+ jpa가 sequence전략이면 MEMBER_SEQ 값만을 가져온후 영속성 컨텍스트에 넣어준다.(call next value for MEMBER_SEQ)
+ 이때 쿼리는 쿼리 저장소에 그대로 있으므로 버퍼링이 가능해진다.
+ 그럼 이런 의구심이 들어야한다. 계속 DB 네트워크를 왔다갔다 해서 성능이 느려지지 않나? allocationsize으로 최적화해보자.

> initialValue allocationsize 성능최적화 기능
+ Defalut allocationSize = 50이다. 
+ 즉 Sequence를 50사이즈로 만들어 놓고, 한번 call할때 DB에 미리 sequence값을 50개올려놓고 가져온다. 

> 연속으로 3개의 값을 영속성 컨테이너가 넣는다고 가정하자.
```
Member member1 = new Member();
        Member member2 = new Member();
        Member member3 = new Member();
        member1.setUsername("A");
        member2.setUsername("B");
        member3.setUsername("C");
        em.persist(member1);
        em.persist(member2);
        em.persist(member3);
```
> DB안의 값
+그림5
+ 시퀀스가 51값이다.(1은 초기에 하나 넘겨주고, 50개를 생성해서 51인것)
> 콘솔 결과창
```
Hibernate: 
    call next value for MEMBER_SEQ    // 이때 1의 값이 영속성 컨테이너로 들어온다
Hibernate: 
    call next value for MEMBER_SEQ    // 이때 2,3의 값을 영속성 컨테이너로 들어온다.(정확히는 50까지)
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```
+ 처음에는 첫값에 1을 맞춰주기 위해 -49가 시퀀스에 들어간다. (allocationSize(50) - 49 = 1(DB값))
+ 첫번째 call next value for MEMBER_SEQ 후 DB에서 1의 값이 영속성 컨테이너에 들어온다.
+ 두번째 call next value for MEMBER_SEQ 후 메모리를 통해 2,3의 값이 영속성 컨테이너에 들어온다.
+ 이미 50까지 call 했기때문에, call 한번에 50개 까지 메모리에 저장되어 있는 것이다.
+ 동시에 여러 서버에서 호출해도 서버 1 : 1~50 개, 서버 2 : 51~100개 서로 나누어 작동되므로 동시성 문제가 일어나지 않는다.

#### TABLE 전략
+ 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
+ 장점: 모든 데이터베이스에 적용 가능
+ 단점: 성능
```
@TableGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        table = "MY_SEQUENCES",
        pkColumnValue = "MEMBER_SEQ", allocationSize = 1)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
```
> 결과창 
```
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255) not null,
        primary key (id)
    )
Hibernate: 
    
    create table MY_SEQUENCES (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    insert into MY_SEQUENCES(sequence_name, next_val) values ('MEMBER_SEQ',0)
```
+ MY_SEQUENCES 테이블을 생성한다.
> 속성
+ 그림6
+ TABLE을 만들뿐 작동방식은 SEQUENCE와 같다.
+ 그런데 잘 안사용한다.

#### 권장하는 식별자 전략
+ 기본 키 제약 조건: null 아님, 유일, 변하면 안된다.
+ 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자. 
+ 예를 들어 주민등록번호도 기본 키로 적절하기 않다. (정치 사회적 문제로 인한 사용불가이슈)
+ 권장: Long형 + 대체키 + 키 생성전략 사용

