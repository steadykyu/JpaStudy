# JPA의 값 타입

## 1. 엔티티 타입
@Entity로 정의하는 객체

식별자가 있어 데이터가 변해도 추적이 가능하다.
```java
@Entity
class Member{...}
```

공유 되는 특징을 가진다.

## 2. 값 타입
식별자 없이 값만 존재하여 데이터가 변할시 추적이 불가능하다.

엔티티 속에 존재하는 여러 값 타입들로 기본값 타입, 임베디드 값 타입, 컬렉션 값 타입이 존재한다.

lifecycle이 엔티티에 의존한다.

공유되지 않고, 불변객체로 만들어 여러 부작용을 피하는 것이 안전하다.

값 타입에 대해 하나하나 알아보자.

### 기본 값 타입

+ 자바 기본 타입(int, double)
+ 래퍼 클래스(Integer, Long)
+ String

Java 기본 타입형은 항상 값을 항상 복사하므로 절대로 공유하면 안된다.
+ 모든 엔티티 객체에 영향을 주므로 private로 생성

래퍼 클래스나 String은 공유가 가능하지만, 변경은 못하게 설정해야한다.(setter 만들지 않기)

### 임베디드 타입(embedded type, 복합 값 타입)

java의 사용자 정의 클래스를 JPA에서는 임베디드 타입이라고 한다.

> 임베디드 타입 생성
```java
@Embeddable
public class Address {
    //   주소
    private String city;
    private String street;
    private String zipcode;

    // 매개변수가 존재하는 생성자 추가시 기본 생성자를 꼭 추가해주어야한다.
    public Address() {
    }

    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
    (gettersetter)
```
기본 생성자가 필수로 존재해야한다.

> 엔티티에서 임베디드 타입 사용시
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    // 주소
    @Embedded
    private Address homeAddress;
```
> main 클래스(트랜잭션이 존재하는 클래스)
```java
            Member member = new Member();
            member.setUsername("hello");
            member.setHomeAddress(new Address("city", "street", "10000"));
            em.persist(member);
```
> 쿼리 결과
```sql
create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        ...
```
임베디드 타입의 필드값들이 Member의 column으로 생성

임베디드 타입의 필드로 다른 엔티티 참조변수를 입력하여 연관관계를 만들어 줄 수 도 있다.

임페디드 타입을 사용하기 전과 후의 매핑하는 테이블은 같다.

> @AttributeOverride: 속성 재정의

한 엔티티에서 같은 임베디드 값 타입을 여러 참조변수에 사용하면, 컬럼 명이 중복되어 에러가 발생한다.

> @AttributeOverrides, @AttributeOverride 구현
```java
@Entity
public class Member {

    @Embedded
    private Address homeAddress;

  @Embedded
    //결과 쿼리 확인 - 따로 컬럼들이 생성된 것을 볼 수 있음.
    @AttributeOverrides({
            @AttributeOverride(name="city",
                    column=@Column(name="WORK_CITY")),
            @AttributeOverride(name="street",
                    column=@Column(name="WORK_STREET")),
            @AttributeOverride(name="zipcode",
                    column=@Column(name="WORK_ZIPCODE"))
    })
    private Address workAddress;
}
```
> 결과 쿼리
```sql
 create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        USERNAME varchar(255),
        ------따로 추가되었음!!
        WORK_CITY varchar(255),             // 
        WORK_STREET varchar(255),
        WORK_ZIPCODE varchar(255),
        ------------------------
        endDate timestamp,
        startDate timestamp,
        primary key (MEMBER_ID)
    )
```

## 3. 값 타입과 불변 객체

### 값 타입 공유 참조

```java
            Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(address);
            em.persist(member2);
            
            member.getHomeAddress().setCity("newCity");     // 임베디드 타입 값 수정
```
DB의 member1, member2 둘다 city에서 newCity가 된다.

address 엔티티객체의 참조값((address객체를 가리키는 참조값)을 공유하고 있기 때문이다.

### 값 타입 복사
```java
            Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Address copyaddress = new Address(address.getCity(), address.getStreet(), address.getZipcode());

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(copyaddress);      // 복사본 인스턴스를 사용
            em.persist(member2);
            member.getHomeAddress().setCity("newCity");
```
인스턴스 값을 복사해서 사용하여, member1에만 newCity로 수정해 줄수 있다.

이와같이 값을 복사해서 사용하면 참조값 직접대입으로 인한 공유 참조로 발생하는 부작용을 피할 수 있다.

기본자료값들은 애초에 값을 복사해서 변수에 대입하므로 공유 참조가 일어나지 않는다.

### 불변 객체(immutable object)

위와 같은 부작용을 막기위해 객체 타입을 수정할 수없도록 불변 객체를 만들 수 있다.

처음 생성자로 값을 설정하고 Setter, Getter를 만들지 않으면 불변 객체를 만들 수 있다.

> 불변 객체의 임베디드 타입을 생성후 다시 주입
```java
        Address address = new Address("city", "street", "10000");

           Member member = new Member();
           member.setUsername("member1");
           member.setHomeAddress(address);
           em.persist(member);
           
           // Address 클래스에 setter가 없다.
           // 새롭게 임베디드 값을 만들어 엔티티 값을 수정하자.
           Address newAddress = new Address("Newcity", address.getStreet(), address.getZipcode());  
           member.setHomeAddress(newAddress);
```

## 4. 값 타입의 비교
> 기본형 값 타입

기본형은 값을 복사해서 비교하므로 ==을 사용한다.

> 참조형(임베디드) 값 타입

동일성(identity) 비교: 인스턴스의 참조값(가리키는 주소)을 비교, == 사용

동등성(equivalence) 비교: 인스턴스의 값을 비교, equals() 사용
+ hashCode()도 재정의 해두어야한다. 

단 값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드사용)
+ 재정의 하지 않으면 Object.equals() 로 참조값을 비교한다.
```java
class Address{
    ...
 @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return Objects.equals(city, address.city) && Objects.equals(street, address.street) && Objects.equals(zipcode, address.zipcode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(city, street, zipcode);
    }
    // 매개변수들로 해시값을 만든다. 
}
//==================================================================================
public static void main(String[] args) {
        int a = 10;
        int b = 10;

        System.out.println(a == b); // true

        Address address1 = new Address("city", "street", "10000");
        Address address2 = new Address("city", "street", "10000");

        System.out.println(address1==address2); //false
        System.out.println(address1.equals(address2));  // 재정의 해줬을시 true
    }
```
## 5.값 타입 컬렉션
값 타입을 하나 이상 저장할 때 사용

```java
public class Member {
    (...)
    // 임베디드 타입
    @Embedded
    private Address homeAddress;      
    
    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
            @JoinColumn(name = "MEMBER_ID")) // FK값
    @Column(name = "FOOD_NAME")              // 따로 정의한 클래스가 없으므로, 우리가 원하는 컬럼을 매핑하도록 강제로 만들어준다.
    private Set<String> favoriteFoods = new HashSet<>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns =
            @JoinColumn(name = "MEMBER_ID"))    //FK값
    private List<Address> addressHistory = new ArrayList<>(); // 여기는 Address클래스안에 필드들이 존재한다. 그러므로 필드명에 맞게 컬럼으로 매핑이 된다.
```
> 결과 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),      // @Embedded 로 인해 생성
        street varchar(255),    // @Embedded
        zipcode varchar(255),   // @Embedded
        USERNAME varchar(255),
        primary key (MEMBER_ID)
    )
=============================================
    create table FAVORITE_FOOD (
       MEMBER_ID bigint not null,
        FOOD_NAME varchar(255)
    )
==============================================
    create table ADDRESS (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255)
    )
```
데이터베이스는 객체의 컬렉션(1대N 구조)을 같은 테이블에 저장할 수 없는 구조이다. 그러므로 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.

### 값 저장
> main(트랜잭션 안)
```java
 Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("homeCity","street","10000"));    // 생성자로 값 주입

            member.getFavoriteFoods().add("치킨");
            member.getFavoriteFoods().add("피자");
            member.getFavoriteFoods().add("족발");    // Hashset에 값들이 들어감

            em.persist(member);

            member.getAddressHistory().add(new Address("old1","street","10000")); 
            member.getAddressHistory().add(new Address("old2","street","10000")); 
            // getAddressHistory의 반환타입이
            // List<Address> 이므로 Address 객체를 add()

            em.flush();
            em.clear(); 
```
member1 엔티티(row)는 id=1을 가지고 있다. 이 member1은 치킨, 피자, 족발을 좋아하고 old1, old2 주소를 저장하고 있도록 DB Table에 값이 들어간다.
(DB그림은 아래 세부 내용에 있으니 헷갈리면 확인요망)

### 값 조회
> main
```java
// ================================================값타입 조회
            Address homeAddress = new Address("city", "street", "10000");
            (..)
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());
            System.out.println("findMember = " + findMember);
            // Member 클래스만 가져오는 쿼리가 나온다.
            // @Embedded 값타입 homeAddress는 Member와 같이 온다.

            List<Address> addressHistory = findMember.getAddressHistory();
            for(Address address : addressHistory){
                System.out.println("address = " + address.getCity());
            }

            Set<String> favoriteFoods = findMember.getFavoriteFoods();
            for( String favoriteFood : favoriteFoods){
                System.out.println("favoriteFood = " + favoriteFood);
            }
            // 사용시마다 쿼리를 가져오고 있다. 즉 컬렉션 값타입은 기본값으로 지연로딩으로 작동되고 있다.
```
> 결과 쿼리
```sql
===============START=========================
Hibernate: 
    select
        member0_.MEMBER_ID as member_i1_6_0_,
        member0_.city as city2_6_0_,              //@Embedded 된 부분은 find 조회시 바로 나온다.
        member0_.street as street3_6_0_,
        member0_.zipcode as zipcode4_6_0_,
        member0_.USERNAME as username5_6_0_ 
    from
        Member member0_ 
    where
        member0_.MEMBER_ID=?
findMember = hellojpa.Member@338766de
Hibernate: 
    select
        addresshis0_.MEMBER_ID as member_i1_0_0_,
        addresshis0_.city as city2_0_0_,
        addresshis0_.street as street3_0_0_,
        addresshis0_.zipcode as zipcode4_0_0_ 
    from
        ADDRESS addresshis0_                      // ADDRESS
    where
        addresshis0_.MEMBER_ID=?
address = old1
address = old2
Hibernate: 
    select
        favoritefo0_.MEMBER_ID as member_i1_4_0_,
        favoritefo0_.FOOD_NAME as food_nam2_4_0_ 
    from
        FAVORITE_FOOD favoritefo0_                  //FAVORITE_FOOD
    where
        favoritefo0_.MEMBER_ID=?
favoriteFood = 족발
favoriteFood = 치킨
favoriteFood = 피자
```
> 값 수정
```java
// ================================================값타입 수정
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());

//          ------------------------------@Embedded값 수정(homeCity -> newCity)
//          setter 사용시 @Embedded에서는 공유참조 부작용이 생기므로 사용 X
//            findMember.getHomeAddress().setCity("new");

//          이런 방식으로 인스턴스 값만 사용하도록 해야한다.
            Address a = findMember.getHomeAddress();
            findMember.setHomeAddress(new Address("newCity", a.getStreet(),a.getZipcode()));

//          ------------------------------Set 컬렉션값 업데이트(치킨대신 -> 한식넣기)
//            findMember.getFavoriteFoods().remove("치킨");
//            findMember.getFavoriteFoods().add("한식");

//          ------------------------------List 컬렉션값 업데이트2(old1 -> new1)
            findMember.getAddressHistory().remove(new Address("old1","street","10000")); 
            // remove는 equals(), hashcode()를 통해 값을 찾고 지운다. 
            findMember.getAddressHistory().add(new Address("new1", "street","10000"));   
            // 새로운 Address 추가
```
remove() 는 Address의 equals(), hashcode()를 이용하여 비교후, 값을 지운다. 그러므로 제대로 재정의가 되어있어야한다.

> 결과 쿼리
```sql
Hibernate: 
    /* delete collection hellojpa.Member.addressHistory */ delete 
        from
            ADDRESS 
        where
            MEMBER_ID=?
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
```
Member 객체를 다지운후, 컬렉션 값을 insert 하는 모습이 보인다. 왜일까?

### 값 타입 컬렉션의 제약 사항
값 타입은 엔티티와 다르게 식별자 개념이 없다.
그러므로 값은 변경하면 추적이 어렵다.

값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.

이런 제약사항은 많은 부작용을 발생시키기 때문에 컬렉션 값타입은 값을 저장하는 용도를 제외하고는 사용하지 않는 것이 좋다.

### 실무적인 컬렉션 해결 방안

그러면 일대다 관계인데 값을 변경하고 추적하기 위해서 JPA는 어떻게 해결할까?

실무에서는 컬렉션관계(일대다)일때 새로운 엔티티를 하나 생성한 후  **일대다 관계 매핑**을 고려한다.

영속성 전이(Cascade) + 고아 객체 제거를 사용해서 엔티티와 라이프사이클을 맞추고, 일대다 매핑을 맺는다. 그럼으로써 컬렉션의 특징을 가지면서 값 변경과 추적에 용이하게 값 을 사용가능 하다.

+ 일대다 매핑은 '다'쪽에 있는 Fk 값을 통해 값을 수정시키므로, Update쿼리로 처리할 수 있다.
> Member와 일대다 관계인 AddressEntity 엔티티 생성 후 작업
```java
@Entity
public class Member {
//    @ElementCollection
//    @CollectionTable(name = "ADDRESS", joinColumns =
//            @JoinColumn(name = "MEMBER_ID"))    //FK값
//    private List<Address> addressHistory = new ArrayList<>();

//    ---------------------일대 다 관계 매핑
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)      
     // 컬렉션의 특징(Member 의존적)과 같이 설정
    @JoinColumn(name ="MEMBER_ID")
    private List<AddressEntity> addressHistory = new ArrayList<>();  
    // 이렇게 해야 활용성도 높고, 쿼리 최적화에도 훨씬 좋은 상태가 된다.
    
        public List<AddressEntity> getAddressHistory() {
        return addressHistory;
    }
}
```
> 값 수정
```java
    member.getAddressHistory().add(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("old2","street","10000"));
    // remove적용을 위해 AddressEntity에서 equals()와 hashcode() 재정의하고 진행
            member.getAddressHistory().remove(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("new1","street","10000"));
```
> 결과 쿼리
```sql
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
```
add()해줄때만 update문 해주는 모습을 볼 수 있다. remove된 부분(old1)은 쿼리가 생성되지 않았다. sql 쓰기 저장소에서 old1에 new1만 update하도록 정리하여 쿼리를 날린 것이다.
***
# 값 타입

### JPA의 데이터 타입 분류(큰 분류)
+ 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자(@id)로 지속해서 추적 가능
  - 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자를 통해 인식 가능
```
식별자 (identifier)는 어떤 대상을 유일하게 식별 및 구별할 수 있는 이름을 뜻한다. 
```
+ 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
  - 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

### 값 타입 분류
+ 기본값 타입
  - 자바 기본 타입(int, double) 
  - 래퍼 클래스(Integer, Long) 
  - String 
+ 임베디드 타입(embedded type, 복합 값 타입) 
+ 컬렉션 값 타입(collection value type)

## 1.기본값 타입
+ 예): String name, int age 
+ 생명주기를 엔티티의 의존
  - 예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제
  - 값 타입은 공유하면 X (생성되는 모든 엔티티 객체에 영향을 끼칠 수 있음.)
  - 예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨

### 자바의 기본 타입은 절대 공유X
+ int, double 같은 기본 타입(primitive type)은 절대 공유 X
    + 그러므로 private 접근 제한자를 가지는게 좋다.
+ 기본 타입은 항상 값을 복사함
+ Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유가능한 객체이지만 변경 할수 없다.
    + 억지로 setValue() 를 만들어야만 변경이 가능하다.
+ 래퍼 클래스나 String은 참조 값으로 값을 조회한다. 참조형 변수끼리는 주소를 옮겨주어 같은 참조값을 바라보고 있으므로 공유가 가능한 객체이다.

## 2.임베디드 타입(복합 값 타입)
+ 새로운 값 타입을 직접 정의할 수 있음
+ JPA는 임베디드 타입(embedded type)이라 함
+ 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
+ 임베디드 타입의 값들은 결국 int, String과 같은 값 타입이다.
    + 사용자 정의 클래스 속에 존재하는 임베디드 값들은 결국 기본값과 같은 취급을 받는다.

<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_1.png">

<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_2.png">

+ DB입장에서는 바뀔게 없고, 매핑만 시켜주면 된다.
### 사용법
```java
@Embeddable
public class Period {
    //  기간 Period
    private LocalDateTime startDate;
    private LocalDateTime endDate;
    (getter, setter)
//==========================================
@Embeddable
public class Address {
    //   주소
    private String city;
    private String street;
    private String zipcode;

    // 매개변수가 존재하는 생성자 추가시 기본 생성자를 꼭 추가해주어야한다.
    public Address() {
    }

    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
    (gettersetter)
//================================================
```
+ @Embeddable: 값 타입을 정의하는 곳에 표시
+ 기본생성자가 필수로 존재해야 한다. 그러므로 매개변수 생성자 추가시 기본생성자를 추가해주자.
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    // 기간
    // 쿼리 확인해보면, 임베디드 값들이 변수로 들어가 있다.
    @Embedded
    private Period workPeriod;          // 만약 "= null" 로 저장시 매핑한 컬럼에도 전부 null이 들어감.
    // 주소
    @Embedded
    private Address homeAddress;
```
> jpamain
```java
            Member member = new Member();
            member.setUsername("hello");
            member.setHomeAddress(new Address("city", "street", "10000"));
            member.setWorkPeriod(new Period());

            em.persist(member);
```
> 결과 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        USERNAME varchar(255),
        endDate timestamp,
        startDate timestamp,
        primary key (MEMBER_ID)
    )
```
+ 임베디드 타입안의 필드값이 컬럼으로 생성되었음.

## 임베디드 타입의 장점
+ 재사용성
+ 높은 응집도
    + 응집도란 한 모듈(클래스) 내부의 처리 요소(필드, 메서드)들이 서로 관련되어 있는 정도
    + 예시의 Period 객체 내에서 Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
+ 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

### 임베디드 타입과 테이블 매핑
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_3.png">

+ 임베디드 타입은 엔티티의 값일 뿐이다. 
+ 임베디드 타입을 사용하기 전과 후에 **매핑하는 테이블은 같다**. 
    + Member -> MEMBER 테이블 와 Team -> team 테이블
    + 임베디드 타입쪽의 값을 수정해도, 매핑 코드는 수정할 필요없다.
+ 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능
+ 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음
+ 현업에서는 자주 쓸일은 없지만, 용어나 코드를 공통으로 사용하여 운영상, 가시성좋은 코드를 쓸 수 있다.
+ 추가 : 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null(코드참고)

### 임베디드 타입과 연관관계
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_4.png">

+ 값 안에 엔티티도 들어올 수 있다. 변수로 엔티티타입의 참조변수만 만들어 주면 된다.
+ ex) Period, Address 안에 다른 엔티티 타입(Zipcode,PhoneEntity)의 참조변수를 넣어주면 된다.

### @AttributeOverride: 속성 재정의
+ 한 엔티티에서 같은 임베디드 값 타입을 여러 참조변수에 사용하면, 컬럼 명이 중복되어 에러가 발생한다.

+ @AttributeOverrides, @AttributeOverride를 사용해서 컬럼 명 속성을 재정의
```java
@Entity
public class Member {

    @Embedded
    private Address homeAddress;

  @Embedded
    //결과 쿼리 확인 - 따로 컬럼들이 생성된 것을 볼 수 있음.
    @AttributeOverrides({
            @AttributeOverride(name="city",
                    column=@Column(name="WORK_CITY")),
            @AttributeOverride(name="street",
                    column=@Column(name="WORK_STREET")),
            @AttributeOverride(name="zipcode",
                    column=@Column(name="WORK_ZIPCODE"))
    })
    private Address workAddress;
}
```
> 결과 쿼리
```sql
 create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        USERNAME varchar(255),
        WORK_CITY varchar(255),             // 따로 추가되었음!!
        WORK_STREET varchar(255),
        WORK_ZIPCODE varchar(255),
        endDate timestamp,
        startDate timestamp,
        primary key (MEMBER_ID)
    )
```

## 3.값 타입과 불변 객체
+ 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 **단순하고 안전하게** 다룰 수 있어야 한다

### 값 타입 공유 참조
+ 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
+ 부작용(side effect) 발생
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_5.png">

> JpaMain
```java

Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(address);
            em.persist(member2);
            
            member.getHomeAddress().setCity("newCity");     // 임베디드 타입 값 수정
```
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_7.png">

+ 만약 개발자가 첫번째 member의 "city"값을 "newCity"로 바꾸고 싶어 위처럼 코드를 작성하면 update 쿼리가 두번 나가고, DB에 member1,member2 둘다 값이 바껴있다.
+ 이런버그는 절대 못잡기때문에 굉장히 위험하다
+ 만약 이렇게 공유하는게 목적으로 사용할 것이었으면 Member 엔티티의 값타입이아니라 **Address엔티티를 만들어야 적합**하다.

### 값 타입 복사
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_6.png">

+ 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다.
+ 대신 값(인스턴스)를 복사해서 사용
```java
            Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Address copyaddress = new Address(address.getCity(), address.getStreet(), address.getZipcode());

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(copyaddress);      // 복사본 인스턴스를 사용
            em.persist(member2);
            member.getHomeAddress().setCity("newCity");
```
### 객체 타입의 한계
+ 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 
+ 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 
+ 자바 기본 타입에 값을 대입하면 값을 복사한다. 
+ 그러나 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.(자바나 JPA가 컴파일이나 실행시에 잡아낼수 있는 방법이 없음)
+ 그러므로 개발자가 조심하지 않는 이상은 객체의 공유 참조는 피할 수 없다.
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_8.png">

### 불변 객체
+ 객체 타입을 수정할 수 없게 만들어 부작용(좋지않은 side effect)을 원천 차단할수 있다.
+ 값 타입은 불변 객체(immutable object)로 설계해야함
+ 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
+ 처음 생성시의 생성자로만 값을 설정하고, 수정자(Setter)를 만들지 않으면 됨(Setter를 지우거나 private으로 변경)
+ 참고: Integer, String은 자바가 제공하는 대표적인 불변 객체
+ **불변이라는 작은 제약으로 부작용이라는 큰 재앙을 막을수 있다.**
> 임베디드 값타입을 새로 생성후 다시 주입
```java
           Member member = new Member();
           member.setUsername("member1");
           member.setHomeAddress(address);
           em.persist(member);
           
           // Address 클래스에 setter를 지운 상태
           // 새롭게 임베디드 값을 만들어 넣어주어, 엔티티 값을 수정하자.
           Address newAddress = new Address("Newcity", address.getStreet(), address.getZipcode());  
           member.setHomeAddress(newAddress);
```
+ 결국 부작용없이 값을 수정하기 위해서는 불변을 위해 setter가 존재하지 않는 임베디드 타입의 값을 새로 생성하여, 엔티티에 다시 넣어주는 방식으로 해야한다.

## 4. 값 타입의 비교
+ 기본형은 값을 복사해서 비교하므로 ==을 사용해도 되지만, 참조형(임베디드) 타입은 아래 내용과 같다.
+ 동일성(identity) 비교: 인스턴스의 참조 값(객체를 가리키는 주소)을 비교, == 사용 
+ 동등성(equivalence) 비교: 인스턴스의 값을 비교, equals() 사용
+ 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야 함
+ **단 값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드사용)**
+ 재정의를 안하면 Object의 equals를 사용하여, 참조값만 비교함.
```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return Objects.equals(city, address.city) && Objects.equals(street, address.street) && Objects.equals(zipcode, address.zipcode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(city, street, zipcode);
    }
//==================================================================================
public static void main(String[] args) {
        int a = 10;
        int b = 10;

        System.out.println(a == b); // true

        Address address1 = new Address("city", "street", "10000");
        Address address2 = new Address("city", "street", "10000");

        System.out.println(address1==address2); //false
        System.out.println(address1.equals(address2));  // 재정의 해줬을시 true
    }
```
+ 참고 : equals()는 intellij에서 제공해주는 alt+insert 기능의 기본 값으로 자동 코드 작성하였다.
+ 실제로 값비교를 해야할 일이 많지는 않지만, 검증이나 상태를 알기 위해 사용하므로 알고는 있자.

## 5.값 타입 컬렉션
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_9.png">

+ 컬렉션 값타입으로 넣어주기 위해서는 별도의 TABLE로 존재해야한다.
+ 값 타입을 하나 이상 저장할 때 사용
+ @ElementCollection, @CollectionTable 사용
```java
public class Member {
    (...)
    // 주소
    @Embedded
    private Address homeAddress;            // 임베디드 타입
    
    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
            @JoinColumn(name = "MEMBER_ID")) // FK값
    @Column(name = "FOOD_NAME")              // 따로 정의한 클래스가 없으므로, 우리가 원하는 컬럼을 매핑하도록 강제로 만들어준다.
    private Set<String> favoriteFoods = new HashSet<>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns =
            @JoinColumn(name = "MEMBER_ID"))    //FK값
    private List<Address> addressHistory = new ArrayList<>(); // 여기는 Address클래스안에 필드값이 존재한다. 그러므로 필드값에 맞게 컬럼으로 매핑이 된다.
```
> 결과 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),      // @Embedded 로 인해 생성
        street varchar(255),    // @Embedded
        zipcode varchar(255),   // @Embedded
        USERNAME varchar(255),
        primary key (MEMBER_ID)
    )
=============================================
    create table FAVORITE_FOOD (
       MEMBER_ID bigint not null,
        FOOD_NAME varchar(255)
    )
==============================================
    create table ADDRESS (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255)
    )
```
+ 데이터베이스는 객체의 컬렉션을 같은 테이블에 저장할 수 없는 구조이다.
  - 1대 다 관계인 컬렉션을 DB안에서는 구현할 방법이 없음.
+ 그러므로 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.

### 값 저장
> jpaMain
```java
            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("homeCity","street","10000"));    // 생성자로 값 주입

            member.getFavoriteFoods().add("치킨");
            member.getFavoriteFoods().add("피자");
            member.getFavoriteFoods().add("족발");    // Hashset에 값들이 들어감

            em.persist(member);

            member.getAddressHistory().add(new Address("old1","street","10000")); // getAddressHistory의 반환타입이
            member.getAddressHistory().add(new Address("old2","street","10000")); // List<Address> 이므로 Address 객체를 add()

            em.flush();
            em.clear();   
```
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_10.png">

+  em.persist(member)만으로 전부 insert쿼리가 날라가 저장되었다.
+  Member의 **라이프 사이클에 의존**하고, 별도로 값수정 할 필요 없이 member에서 값만 바꾸면 된다.
+  마치 Member객체의 필드변수들 처럼 그저 값 타입일 뿐이다.
+  참고: 값 타입 컬렉션은 엔티티의 영속성 전이(CascadeType.All)에 + 고아 객체 제거 기능(orphanRemoval = true)을 필수로 가진다고 볼 수 있다.
### 값 조회
> JpaMain
```java
            (저장 코드 이후 추가)
            // ================================================값타입 조회
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());
            System.out.println("findMember = " + findMember);
            //보면 Member 클래스만 가져오는 쿼리가 나온다.
            // @Embedded 상태인 homeAddress는 Member와 같이 온다.

            List<Address> addressHistory = findMember.getAddressHistory();
            for(Address address : addressHistory){
                System.out.println("address = " + address.getCity());
            }

            Set<String> favoriteFoods = findMember.getFavoriteFoods();
            for( String favoriteFood : favoriteFoods){
                System.out.println("favoriteFood = " + favoriteFood);
            }
            // 사용시마다 쿼리를 가져오고 있다. 즉 컬렉션들은 기본값으로 지연로딩으로 작동되고 있다.(fetch 옵션으로 확인가능)
```
> 결과 쿼리
```
===============START=========================
Hibernate: 
    select
        member0_.MEMBER_ID as member_i1_6_0_,
        member0_.city as city2_6_0_,              //@Embedded 된 부분은 find 조회시 바로 나온다.
        member0_.street as street3_6_0_,
        member0_.zipcode as zipcode4_6_0_,
        member0_.USERNAME as username5_6_0_ 
    from
        Member member0_ 
    where
        member0_.MEMBER_ID=?
findMember = hellojpa.Member@338766de
Hibernate: 
    select
        addresshis0_.MEMBER_ID as member_i1_0_0_,
        addresshis0_.city as city2_0_0_,
        addresshis0_.street as street3_0_0_,
        addresshis0_.zipcode as zipcode4_0_0_ 
    from
        ADDRESS addresshis0_                      // ADDRESS
    where
        addresshis0_.MEMBER_ID=?
address = old1
address = old2
Hibernate: 
    select
        favoritefo0_.MEMBER_ID as member_i1_4_0_,
        favoritefo0_.FOOD_NAME as food_nam2_4_0_ 
    from
        FAVORITE_FOOD favoritefo0_                  //FAVORITE_FOOD
    where
        favoritefo0_.MEMBER_ID=?
favoriteFood = 족발
favoriteFood = 치킨
favoriteFood = 피자
```
+ 처음에는 Member 클래스만 가져오는 쿼리가 나온다.(@Embedded 상태인 homeAddress가 참조하는 Address값은 Member와 같이 온다.)
+ 사용시마다 쿼리를 가져오고 있다. 즉 컬렉션들은 기본값으로 **지연로딩으로 작동**되고 있다.(@ElementCollection의 fetch 옵션에서 확인가능)

### 값 수정
```java
            (저장 코드 이후로 진행)
            // ================================================값타입 수정
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());

//          ------------------------------@Embedded값 수정(homeCity -> newCity)
//          setter 가 있다고 가정시 @Embedded에서는 이전에 말한 부작용이 생기므로 사용 X
//            findMember.getHomeAddress().setCity("new");

//          이런 방식으로 Address를 새로운 것으로 껴주어야 한다.
            Address a = findMember.getHomeAddress();
            findMember.setHomeAddress(new Address("newCity", a.getStreet(),a.getZipcode()));

//          ------------------------------컬렉션값 업데이트(치킨대신 -> 한식넣기)
//            findMember.getFavoriteFoods().remove("치킨");
//            findMember.getFavoriteFoods().add("한식");

//          ------------------------------컬렉션값 업데이트2(old1 -> new1)
            findMember.getAddressHistory().remove(new Address("old1","street","10000")); // remove는 equals(), hashcode()를 통해 값을 찾고 지운다. 
            findMember.getAddressHistory().add(new Address("new1", "street","10000"));   // 새로운 Address 추가
```
+ remove() 는 Address의 equals(), hashcode()를 이용하여 비교후, 값을 지운다. 만약 제대로 오버라이드가 안되있다면 remove가 제대로 동작하지 않는다.
> 결과 쿼리
```sql
Hibernate: 
    /* delete collection hellojpa.Member.addressHistory */ delete 
        from
            ADDRESS 
        where
            MEMBER_ID=?
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
```
+ DB에 값은 잘 들어갔지만, 진행 쿼리를 보면 delete ADDRESS 쿼리 후에, 두번 insert해주고 있다.(만약 100개 남았다면 100번 insert했을 것)
+ 즉 현재 한 멤버(member)의 member_id = ? 인 부분을 다지우고, 남아야하는 o1d2와 , 추가된 new1를 insert하고 있다.
+ 컬렉션은 DB입장 보면 값을 쉽게 찾아내기가 쉽지 않다. 그러므로 이런 방식으로 진행하는데 이렇게 진행되는건 비효율적이며 위험하다.

### 값 타입 컬렉션의 제약사항
+ 값 타입은 엔티티와 다르게 식별자 개념이 없다. 
+ 그러므로 값은 변경하면 추적이 어렵다. 
+ 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 
+ 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키(PK)를 구성해야 함: null 입력X, 중복 저장X
  - 모든 컬럼을 연결하여 PK값을 구성

### 값 타입 컬렉션 대안
+ 위같은 제약사항때문에 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려한다.

+ 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용한다.

+ 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 엔티티와 라이프 사이클을 동등하게 만들고, 컬렉션 값 타입(= 특징과 유사하게 만들어서) 처럼 사용
> AddressEntitiy 생성
```java
@Entity
@Table(name = "ADDRESS")        // ADDRESS_ENTITIY 대신 ADDRESS로 생성
public class AddressEntitiy {

    @Id
    @GeneratedValue
    private Long id;

    private Address address;                  // Address 값타입을 멤버변수로 가짐.

    public AddressEntitiy() {
    }

    public AddressEntitiy(Address address) {           
        this.address = address;
    }

    public AddressEntitiy(String city, String street, String zipcode) {     // 값 주입을 위한 생성자.
        this.address = new Address(city,street,zipcode);
    }
```
> 일대다 관계 매핑
```java
@Entity
public class Member {
    (...)
//    ---------------------이전의 컬렉션 작업    
    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
            @JoinColumn(name = "MEMBER_ID")) //FK
    @Column(name = "FOOD_NAME")              
    private Set<String> favoriteFoods = new HashSet<>();

//    @ElementCollection
//    @CollectionTable(name = "ADDRESS", joinColumns =
//            @JoinColumn(name = "MEMBER_ID"))    //FK값
//    private List<Address> addressHistory = new ArrayList<>();

//    ---------------------일대 다 관계 매핑
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)       // 컬렉션의 특징(Member 의존적)과 같이 설정
    @JoinColumn(name ="MEMBER_ID")
    private List<AddressEntity> addressHistory = new ArrayList<>();  // 이렇게 해야 활용성도 높고, 쿼리 최적화에도 훨씬 좋은 상태가 된다.
    
        public List<AddressEntity> getAddressHistory() {
        return addressHistory;
    }

    public void setAddressHistory(List<AddressEntity> addressHistory) {
        this.addressHistory = addressHistory;
    }
}
```
> jpaMain
```java
           Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("homeCity","street","10000"));    // 생성자로 값 주입

            em.persist(member);

            member.getAddressHistory().add(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("old2","street","10000"));
            ==========================================================================
```
> 쿼리결과
```sql
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
```
+ 일대 다 연관관계 매핑이면 FK가 '다'쪽에 있으므로, 값을 추가할때 마다 ADDRESS TABLE에 update 쿼리가 나가는 모습을 볼 수 있다.(member값의 변화를 update로 처리)
+ h2 db에 ADDRESS TABLE로 엔티티를 생성하였으므로, 자체적 ID 즉 FK가 생성된 모습을 볼수있다.
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/9_11.png">

+ 값 수정(old1 -> new1)
```java         
            member.getAddressHistory().add(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("old2","street","10000"));
    // remove적용을 위해 AddressEntity에서 equals()와 hashcode() 재정의하고 진행
            member.getAddressHistory().remove(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("new1","street","10000"));
```
> 결과쿼리
```sql
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?

```
add()해줄때만 update문 해주는 모습을 볼 수 있다. remove된 부분(old1)은 쿼리가 생성되지 않았다. sql 쓰기 저장소에서 old1에 new1만 update하도록 정리하여 쿼리를 날린 것이다.

이전 컬렉션은 Delete문 이후 insert문을 호출했는데, 엔티티를 통한 수정이 훨씬 안정적으로 효율적이다.

### 정리
+ 엔티티 타입의 특징
    - 식별자O 
    - 생명 주기 관리
    - 공유
+ 값 타입의 특징
    - 식별자X 
    - 생명 주기를 엔티티에 의존
    - 공유하지 않는 것이 안전(복사해서 사용) 
    - 불변 객체로 만드는 것이 안전

### 그럼 결과적으로 언제 컬렉션을 쓰는가?
```
값 타입은 정말 값 타입이라 판단될 때만 사용( 주로 저장만 쓰이는 간단한 작업 )
엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨.
식별자가 필요하고, 지속해서 값을 추적(조회), 변경해야 한다면 그것은 값 타입이 아닌 엔티티
```
### 실전
```
city, street, zipcode 필드를 가진 Address 클래스를 만든후 @Embeddable 값타입으로 만든다. 
Member, Delivery 클래스에서 앞의 필드들을 제거하고 Address 참조변수를 생성하여 좀더 보기 좋은 코드를 만들었다.
```
