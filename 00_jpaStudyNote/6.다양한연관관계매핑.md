

## 연관관계 매핑시 고려사항 3가지
+ 다중성
+ 단방향, 양방향
+ 연관관계의 주인

### 다중성
> 앞으로 나올 내용으로, 앞글자가 연관관계 주인이다.
+ 다대일: @ManyToOne 
+ 일대다: @OneToMany 
+ 일대일: @OneToOne 
+ 다대다: @ManyToMany

### 단방향, 양방향
+ 테이블
```
외래 키 하나로 양쪽 조인 가능
사실 방향이라는 개념이 없음
```
+ 객체
```
참조용 필드가 있는 쪽으로만 참조 가능
한쪽만 참조하면 단방향
양쪽이 서로 참조하면 양방향(양방향 보다는 서로 단방향인 개념)
```

### 연관관계 주인
+ 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
+ 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데이다. 그러므로 둘중 테이블의 외래 키를 관리할 곳을 지정해야함
+ 연관관계의 주인: 외래 키를 관리하는 참조( '다' 쪽에 놔야함)
+ 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 1.다대일 N:1
### 다대일 단방향
>그림1
+ 가장 많이 사용하는 연관관계
+ 다대일의 반대는 일대다
### 다대일 양방향
>그림2
+ 외래 키가 있는 쪽이 연관관계의 주인
+ 양쪽을 서로 참조하도록 개발
+ 중요한건 이 참조변수의 추가가 Table에 영향을 주지 않는다.(FK는 고정이므로)

## 1.일대다 1:N
> 코드
```
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;

    @OneToMany                   
    @JoinColumn(name = "TEAM_ID")                     //Team쪽에 연관관계 매핑을 위한 JoinColumn이 들어간다.
    private List<Member> members = new ArrayList<>();
```
+ Team쪽에 @JoinColumn(name = "TEAM_ID")를 추가하고 Member쪽의 team 참조변수를 없앤다.
>그림3
### 일대다 단방향 정리
+ 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
+ 테이블 일대다 관계는 **항상 다(N)** 쪽에 외래 키가 있음
```
TABLE입장에서는 MEMBER_ID  FK가 되버리면 중복되는 ROW들이 생기므로 구별이 불가능해진다. 
그러므로 무조건 MEMBER에 FK가 있어야한다.
```
+ 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
+ @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함
```
@JoinTable을 없을시 두 테이블을 Join 새로운 TABLE(Member_Team)을 만들어서 작업한다.
```
+ 일대다 단방향 매핑의 단점
```
엔티티가 관리하는 외래 키가 다른 테이블에 있음
연관관계 관리를 위해 commit시 추가로 MEMBER TABLE에 UPDATE SQL쿼리를 날리고 실행
```
+ 왠만하면 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

### 일대다 양방향
>그림 4

### 일대다 양방향 정리
+ 이런 매핑은 공식적으로 존재X 
+ @JoinColumn(insertable=false, updatable=false)으로 필드를 읽기 전용필드를 만들수 있다.
• 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
• 왠만하면 다대일 양방향을 사용하자

## 1.다대일 N:1

## 1.다대일 N:1
