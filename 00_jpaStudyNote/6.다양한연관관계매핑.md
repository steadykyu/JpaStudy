## 요약
+ 이전과 크게 다르지 않게 다대일 단방향 매핑으로 주로하고, 필요에 따라 양방향으로 만든다. 
+ 일대일 매핑은 설계시 고려해보아야하지만 FK를 주테이블에 놓는것이 일반적으로 좋다.
+ 다대다 매핑은 다대일 매핑을 두번하는 연결테이블용 엔티티를 추가해서 작업한다.

## 연관관계 매핑시 고려사항 3가지
+ 다중성
+ 단방향, 양방향
+ 연관관계의 주인

### 다중성
> 앞으로 나올 내용으로, 앞글자가 연관관계 주인이다.
+ 다대일: @ManyToOne 
+ 일대다: @OneToMany 
+ 일대일: @OneToOne 
+ 다대다: @ManyToMany

### 단방향, 양방향
+ 테이블
```
외래 키 하나로 양쪽 조인 가능
사실 방향이라는 개념이 없음
```
+ 객체
```
참조용 필드가 있는 쪽으로만 참조 가능
한쪽만 참조하면 단방향
양쪽이 서로 참조하면 양방향(양방향 보다는 서로 단방향인 개념)
```

### 연관관계 주인
+ 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
+ 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데이다. 그러므로 둘중 테이블의 외래 키를 관리할 곳을 지정해야함
+ 연관관계의 주인: 외래 키를 관리하는 참조( '다' 쪽에 놔야함)
+ 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 1.다대일 N:1
### 다대일 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_1.png">

+ 가장 많이 사용하는 연관관계
+ 다대일의 반대는 일대다
### 다대일 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_2.png">

+ 외래 키가 있는 쪽이 연관관계의 주인
+ 양쪽을 서로 참조하도록 개발
+ 중요한건 이 참조변수의 추가가 Table에 영향을 주지 않는다.(FK는 고정이므로)

## 1.일대다 1:N
> 코드
```
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;

    @OneToMany                   
    @JoinColumn(name = "TEAM_ID")                     //Team쪽에 연관관계 매핑을 위한 JoinColumn이 들어간다.
    private List<Member> members = new ArrayList<>();
```
+ Team쪽에 @JoinColumn(name = "TEAM_ID")를 추가하고 Member쪽의 team 참조변수를 없앤다.
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_3.png">

### 일대다 단방향 정리
+ 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
+ 테이블 일대다 관계는 **항상 다(N)** 쪽에 외래 키가 있음
```
TABLE입장에서는 MEMBER_ID  FK가 되버리면 중복되는 ROW들이 생기므로 구별이 불가능해진다. 
그러므로 무조건 MEMBER에 FK가 있어야한다.
```
+ 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
+ @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함
```
@JoinTable을 없을시 두 테이블을 Join 새로운 TABLE(Member_Team)을 만들어서 작업한다.
```
+ 일대다 단방향 매핑의 단점
```
엔티티가 관리하는 외래 키가 다른 테이블에 있음
연관관계 관리를 위해 commit시 추가로 MEMBER TABLE에 UPDATE SQL쿼리를 날리고 실행
```
+ 왠만하면 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

### 일대다 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_4.png">

### 일대다 양방향 정리
+ 이런 매핑은 공식적으로 존재X 
+ @JoinColumn(insertable=false, updatable=false)으로 필드를 읽기 전용필드를 만들수 있다.
• 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
• 왠만하면 다대일 양방향을 사용하자

## 3.일대일 1:1
+ 일대일 관계는 그 반대도 일대일
+ 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
```
주 테이블에 외래 키
대상 테이블에 외래 키
주 테이블 : 주로 access(select) 하는 테이블
```
• 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

### 일대일: 주 테이블에 외래 키 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_5.png">

+ 다대일(@ManyToOne) 단방향 매핑과 유사
+ 코드작업
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")         //
    private Locker locker;
    (...)
```
### 일대일: 주 테이블에 외래 키 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_6.png">

+ 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인
+ 반대편은 mappedBy 적용
+ 코드작업
```
@Entity
public class Locker {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToOne(mappedBy = "locker")      // mappedBy 추가!
    private Member member;
}
```
### 일대일: 대상 테이블에 외래 키 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_7.png">

+ 단방향 관계는 JPA 지원X
+ FK를 이동시키는 양방향 관계는 지원
### 일대일: 대상 테이블에 외래 키 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_8.png">

+ 사실 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음(FK만 이동한것)

### 일대일 정리
+ 주 테이블에 외래 키
+ 일대일: 주 테이블에 외래 키 양방향 그림참고
```
• 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
• 객체지향 개발자 선호
• JPA 매핑 편리
• 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
• 단점: 값이 없으면 외래 키에 null 허용
```
+ 대상 테이블에 외래 키
+ 일대일: 대상 테이블에 외래 키 양방 그림참고
```
• 대상 테이블에 외래 키가 존재
• 전통적인 데이터베이스 개발자 선호
• 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
• 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)
```
## 1.다대다 N:M
### 다대다
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_9.png">

+ 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
+ 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
+ 객체는 서로 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
```
@Entity
public class Member {
    @ManyToMany
    @JoinTable(name="MEMBER_PRODUCT")                   // MEMBER_PRODUCT 이 생성되고 값이 들어간다.
    private List<Product> products = new ArrayList<>();
    (...)
-----------------------------------------------------------
@Entity
public class Product {
    @ManyToMany(mappedBy = "products")
    private List<Member> members = new ArrayList<>();
    (...)
```
+  다대다 매핑: 단방향, 양방향 가능

### 다대다 매핑의 한계
+ 편리해 보이지만 실무에서 사용X 
+ 실무에서는 연결 테이블이 단순히 연결만 하고 끝나지 않는다. 주문시간, 수량 같은 데이터가 들어올 수 있음
+ 다대다 매핑에서는 추가가 불가능하다.
+ 쿼리도 복잡한 모양으로 생성된다.

### 다대다 한계 극복
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_10.png">

+ 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) 
+ @ManyToMany 대신 연결 테이블용 엔티티에 @OneToMany, @ManyToOne을 추가한다.
+ Member와 Product에 읽기 전용의 참조변수를 추가하고 mappedby해준다.
```java
@Entity
public class MemberProduct {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    
    private Product product;                // 새로운 필드들(테이블column) 추가가능!

    private int count;
    private int price;

    private LocalDateTime orderDateTime;
}
```
+ 운영적으로 가운데 테이블의 pk 와 fk는 따로 두는게 시스템을 유연하게 만들수 있다.(나중에 나옴)

## 4. 실전
코드 작업밖에 없어서 추가 자료를 첨부한다.
### 여러 옵션들의 속성
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_11.png">

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_12.png">

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_13.png">
