# 값 타입

### JPA의 데이터 타입 분류(큰 분류)
+ 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능
  - 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
```
식별자 (identifier)는 어떤 대상을 유일하게 식별 및 구별할 수 있는 이름을 뜻한다. 
```
+ 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
  - 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

### 값 타입 분류
+ 기본값 타입
  - 자바 기본 타입(int, double) 
  - 래퍼 클래스(Integer, Long) 
  - String 
+ 임베디드 타입(embedded type, 복합 값 타입) 
+ 컬렉션 값 타입(collection value type)

## 1.기본값 타입
+ 예): String name, int age 
+ 생명주기를 엔티티의 의존
  - 예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제
  - 값 타입은 공유하면X 
  - 예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨

### 자바의 기본 타입은 절대 공유X
+ int, double 같은 기본 타입(primitive type)은 절대 공유X 
+ 기본 타입은 항상 값을 복사함
+ Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유가능한 객체이지만 변경X(억지로 setValue() 를 만들어서 바꾸지 않는한 변경이 불가능하다.)
+ 래퍼 클래스나 String은 참조 값으로 값을 조회하고, 참조형 변수끼리는 주소를 옮겨주어 같은 참조값을 바라보고 있으므로 공유가 가능한 객체이다.

## 2.임베디드 타입(복합 값 타입)
+ 새로운 값 타입을 직접 정의할 수 있음
+ JPA는 임베디드 타입(embedded type)이라 함
+ 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
+ int, String과 같은 값 타입
+ 그림1
+ 그림2

+ DB입장에서는 바뀔게 없고, 매핑만 시켜주면 된다.
### 사용법
```java
@Embeddable
public class Period {
    //  기간 Period
    private LocalDateTime startDate;
    private LocalDateTime endDate;
    (getter, setter)
//==========================================
@Embeddable
public class Address {
    //   주소
    private String city;
    private String street;
    private String zipcode;

    // 매개변수가 존재하는 생성자 추가시 기본 생성자를 꼭 추가해주어야한다.
    public Address() {
    }

    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
    (gettersetter)
//================================================
```
+ @Embeddable: 값 타입을 정의하는 곳에 표시
+ 기본생성자가 필수로 존재해야 한다. 그러므로 매개변수 생성자 추가시 기본생성자를 추가해주자.
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    // 기간
    // 쿼리 확인해보면, 임베디드 값들이 변수로 들어가 있다.
    @Embedded
    private Period workPeriod;          // 만약 "= null" 로 저장시 매핑한 컬럼에도 전부 null이 들어감.
    // 주소
    @Embedded
    private Address homeAddress;
```
> jpamain
```java
            Member member = new Member();
            member.setUsername("hello");
            member.setHomeAddress(new Address("city", "street", "10000"));
            member.setWorkPeriod(new Period());

            em.persist(member);
```
> 결과 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        USERNAME varchar(255),
        endDate timestamp,
        startDate timestamp,
        primary key (MEMBER_ID)
    )
```
+ 임베디드 타입안의 필드값이 컬럼으로 생성되었음.

## 임베디드 타입의 장점
+ 재사용
+ 높은 응집도
+ 예시의 Period 객체 내에서 Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
+ 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

### 임베디드 타입과 테이블 매핑
+ 그림3

+ 임베디드 타입은 엔티티의 값일 뿐이다. 
+ 임베디드 타입을 사용하기 전과 후에 **매핑하는 테이블은 같다**. 
+ 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능
+ 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음
+ 현업에서는 자주 쓸일은 없지만, 용어나 코드를 공통으로 사용하여 운영상, 가시성좋은 코드를 쓸 수 있다.
+ 추가 : 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null(코드참고)

### 임베디드 타입과 연관관계
+ 그림4

+ 값 안에 엔티티도 들어올 수 있다. 변수로 엔티티타입의 참조변수만 만들어 주면 된다.
+ ex) Period, Address 안에 Member 또는 다른 엔티티 타입의 참조변수를 넣어주면 된다.

### @AttributeOverride: 속성 재정의
+ 한 엔티티에서 같은 값 타입을 여러 참조변수에 사용하면, 컬럼 명이 중복되어 에러가 발생한다.
+ @AttributeOverrides, @AttributeOverride를 사용해서 컬럼 명 속성을 재정의
```java
@Entity
public class Member {
  @Embedded
    //결과 쿼리 확인 - 따로 컬럼들이 생성된 것을 볼 수 있음.
    @AttributeOverrides({
            @AttributeOverride(name="city",
                    column=@Column(name="WORK_CITY")),
            @AttributeOverride(name="street",
                    column=@Column(name="WORK_STREET")),
            @AttributeOverride(name="zipcode",
                    column=@Column(name="WORK_ZIPCODE"))
    })
    private Address workAddress;
}
```
> 결과 쿼리
```sql
 create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        USERNAME varchar(255),
        WORK_CITY varchar(255),             // 따로 추가되었음!!
        WORK_STREET varchar(255),
        WORK_ZIPCODE varchar(255),
        endDate timestamp,
        startDate timestamp,
        primary key (MEMBER_ID)
    )
```

## 3.값 타입과 불변 객체
+ 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 **단순하고 안전하게** 다룰 수 있어야 한다

### 값 타입 공유 참조
+ 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
+ 부작용(side effect) 발생
+ 그림5
> JpaMain
```java

Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(address);
            em.persist(member2);
            
            member.getHomeAddress().setCity("newCity");     // 임베디드 타입 값 수정
```
+ 그림7 (순서한번이상함)

+ 만약 개발자가 첫번째 member의 "city"값을 "newCity"로 바꾸고 싶어 위처럼 코드를 작성하면 update 쿼리가 두번 나가고, DB에 member1,member2 둘다 값이 바껴있다.
+ 이런버그는 절대 못잡기때문에 굉장히 위험하다
+ 만약 이렇게 공유하는게 목적으로 사용할 것이었으면 값타입이아니라 **Address엔티티를 만들어야 적합**하다.

### 값 타입 복사
+그림6
+ 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다.
+ 대신 값(인스턴스)를 복사해서 사용
```java
            Address address = new Address("city", "street", "10000");

            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(address);
            em.persist(member);

            Address copyaddress = new Address(address.getCity(), address.getStreet(), address.getZipcode());

            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setHomeAddress(copyaddress);      // 복사본 인스턴스를 사용
            em.persist(member2);
            member.getHomeAddress().setCity("newCity");
```
### 객체 타입의 한계
+ 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 
+ 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 
+ 자바 기본 타입에 값을 대입하면 값을 복사한다. 
+ 그러나 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.(자바나 JPA가 컴파일이나 실행시에 잡아낼수 있는 방법이 없음)
+ 그러므로 개발자가 조심하지 않는 이상은 객체의 공유 참조는 피할 수 없다.
+ 그림 8

### 불변 객체
+ 객체 타입을 수정할 수 없게 만들어 부작용(좋지않은 side effect)을 원천 차단할수 있다.
+ 값 타입은 불변 객체(immutable object)로 설계해야함
+ 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
+ 처음 생성시의 생성자로만 값을 설정하고, 수정자(Setter)를 만들지 않으면 됨(Setter를 지우거나 private으로 변경)
+ 참고: Integer, String은 자바가 제공하는 대표적인 불변 객체
+ **불변이라는 작은 제약으로 부작용이라는 큰 재앙을 막을수 있다.**
> 임베디드 값타입을 새로 생성후 다시 주입
```java
           Member member = new Member();
           member.setUsername("member1");
           member.setHomeAddress(address);
           em.persist(member);
           
           // Address 클래스에 setter를 지운 상태
           // 새롭게 임베디드 값을 만들어 넣어주어, 엔티티 값을 수정하자.
           Address newAddress = new Address("Newcity", address.getStreet(), address.getZipcode());  
           member.setHomeAddress(newAddress);
```
+ 결국 부작용없이 값을 수정하기 위해서는 불변을 위해 setter가 존재하지 않는 임베디드 타입의 값을 새로 생성하여, 엔티티에 다시 넣어주는 방식으로 해야한다.

## 4. 값 타입의 비교
+ 기본형은 값을 복사해서 비교하므로 ==을 사용해도 되지만, 참조형(임베디드) 타입은 아래 내용과 같다.
+ 동일성(identity) 비교: 인스턴스의 참조 값을 비교, == 사용 
+ 동등성(equivalence) 비교: 인스턴스의 값을 비교, equals() 사용
+ 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야 함
+ **단 값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드사용)**
+ 재정의를 안하면 Object의 equals를 사용하여, 참조값만 비교함.
```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return Objects.equals(city, address.city) && Objects.equals(street, address.street) && Objects.equals(zipcode, address.zipcode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(city, street, zipcode);
    }
//==================================================================================
public static void main(String[] args) {
        int a = 10;
        int b = 10;

        System.out.println(a == b); // true

        Address address1 = new Address("city", "street", "10000");
        Address address2 = new Address("city", "street", "10000");

        System.out.println(address1==address2); //false
        System.out.println(address1.equals(address2));  // 재정의 해줬을시 true
    }
```
+ 참고 : equals()는 intellij에서 제공해주는 alt+insert 기능의 기본 값으로 자동 코드 작성하였다.
+ 실제로 값비교를 해야할 일이 많지는 않지만, 검증이나 상태를 알기 위해 사용하므로 알고는 있자.

## 5.값 타입 컬렉션
+ 그림9

+ 컬렉션에 대하여 별도의 TABLE로 뽑아야함.
+ 값 타입을 하나 이상 저장할 때 사용
+ @ElementCollection, @CollectionTable 사용
```
public class Member {
    (...)
    // 주소
    @Embedded
    private Address homeAddress;            // 임베디드 타입
    
    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
            @JoinColumn(name = "MEMBER_ID")) // FK값
    @Column(name = "FOOD_NAME")              // 따로 정의한 클래스가 없으므로, 우리가 원하는 컬럼을 매핑하도록 강제로 만들어준다.
    private Set<String> favoriteFoods = new HashSet<>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns =
            @JoinColumn(name = "MEMBER_ID"))    //FK값
    private List<Address> addressHistory = new ArrayList<>(); // 여기는 Address클래스안에 필드값이 존재한다. 그러므로 필드값에 맞게 컬럼으로 매핑이 된다.
```
> 결과 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),      // @Embedded 로 인해 생성
        street varchar(255),    // @Embedded
        zipcode varchar(255),   // @Embedded
        USERNAME varchar(255),
        primary key (MEMBER_ID)
    )
=============================================
    create table FAVORITE_FOOD (
       MEMBER_ID bigint not null,
        FOOD_NAME varchar(255)
    )
==============================================
    create table ADDRESS (
       MEMBER_ID bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255)
    )
```
+ 데이터베이스는 객체의 컬렉션을 같은 테이블에 저장할 수 없는 구조이다.
  - 1대 다 관계인 컬렉션을 DB안에서는 구현할 방법이 없음.
+ 그러므로 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.

### 값 저장
> jpaMain
```java
            Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("homeCity","street","10000"));    // 생성자로 값 주입

            member.getFavoriteFoods().add("치킨");
            member.getFavoriteFoods().add("피자");
            member.getFavoriteFoods().add("족발");    // Hashset에 값들이 들어감

            em.persist(member);

            member.getAddressHistory().add(new Address("old1","street","10000")); // getAddressHistory의 반환타입이
            member.getAddressHistory().add(new Address("old2","street","10000")); // List<Address> 이므로 Address 객체를 add()

            em.flush();
            em.clear();   
```
+ 그림10

+  em.persist(member)만으로 전부 insert쿼리가 날라가 저장되었다.
+  Member의 **라이프 사이클에 의존**하고, 별도로 값수정 할 필요 없이 member에서 값만 바꾸면 된다.
+  마치 Member객체의 필드변수들 처럼 그저 값 타입일 뿐이다.
+  참고: 값 타입 컬렉션은 엔티티의 영속성 전이(CascadeType.All)에 + 고아 객체 제거 기능(orphanRemoval = true)을 필수로 가진다고 볼 수 있다.
### 값 조회
> JpaMain
```java
            (저장 코드 이후 추가)
            // ================================================값타입 조회
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());
            System.out.println("findMember = " + findMember);
            //보면 Member 클래스만 가져오는 쿼리가 나온다.
            // @Embedded 상태인 homeAddress는 Member와 같이 온다.

            List<Address> addressHistory = findMember.getAddressHistory();
            for(Address address : addressHistory){
                System.out.println("address = " + address.getCity());
            }

            Set<String> favoriteFoods = findMember.getFavoriteFoods();
            for( String favoriteFood : favoriteFoods){
                System.out.println("favoriteFood = " + favoriteFood);
            }
            // 사용시마다 쿼리를 가져오고 있다. 즉 컬렉션들은 기본값으로 지연로딩으로 작동되고 있다.(fetch 옵션으로 확인가능)
```
> 결과 쿼리
```
===============START=========================
Hibernate: 
    select
        member0_.MEMBER_ID as member_i1_6_0_,
        member0_.city as city2_6_0_,              //@Embedded 된 부분은 find 조회시 바로 나온다.
        member0_.street as street3_6_0_,
        member0_.zipcode as zipcode4_6_0_,
        member0_.USERNAME as username5_6_0_ 
    from
        Member member0_ 
    where
        member0_.MEMBER_ID=?
findMember = hellojpa.Member@338766de
Hibernate: 
    select
        addresshis0_.MEMBER_ID as member_i1_0_0_,
        addresshis0_.city as city2_0_0_,
        addresshis0_.street as street3_0_0_,
        addresshis0_.zipcode as zipcode4_0_0_ 
    from
        ADDRESS addresshis0_                      // ADDRESS
    where
        addresshis0_.MEMBER_ID=?
address = old1
address = old2
Hibernate: 
    select
        favoritefo0_.MEMBER_ID as member_i1_4_0_,
        favoritefo0_.FOOD_NAME as food_nam2_4_0_ 
    from
        FAVORITE_FOOD favoritefo0_                  //FAVORITE_FOOD
    where
        favoritefo0_.MEMBER_ID=?
favoriteFood = 족발
favoriteFood = 치킨
favoriteFood = 피자
```
+ 처음에는 Member 클래스만 가져오는 쿼리가 나온다.(@Embedded 상태인 homeAddress가 참조하는 Address값은 Member와 같이 온다.)
+ 사용시마다 쿼리를 가져오고 있다. 즉 컬렉션들은 기본값으로 **지연로딩으로 작동**되고 있다.(@ElementCollection의 fetch 옵션에서 확인가능)

### 값 수정
```java
            (저장 코드 이후로 진행)
            // ================================================값타입 수정
            System.out.println("===============START=========================");
            Member findMember = em.find(Member.class, member.getId());

//          ------------------------------@Embedded값 수정(homeCity -> newCity)
//          setter 가 있다고 가정시 @Embedded에서는 이전에 말한 부작용이 생기므로 사용 X
//            findMember.getHomeAddress().setCity("new");

//          이런 방식으로 Address를 새로운 것으로 껴주어야 한다.
            Address a = findMember.getHomeAddress();
            findMember.setHomeAddress(new Address("newCity", a.getStreet(),a.getZipcode()));

//          ------------------------------컬렉션값 업데이트(치킨대신 -> 한식넣기)
//            findMember.getFavoriteFoods().remove("치킨");
//            findMember.getFavoriteFoods().add("한식");

//          ------------------------------컬렉션값 업데이트2(old1 -> new1)
            findMember.getAddressHistory().remove(new Address("old1","street","10000")); // remove는 equals(), hashcode()를 통해 값을 찾고 지운다. 
            findMember.getAddressHistory().add(new Address("new1", "street","10000"));   // 새로운 Address 추가
```
+ remove()는 equals()와 hashcode()가 꼭 알맞게 재정의 되어있어야 한다. 만약 제대로 안되있다면 지우지 않는다.
> 결과 쿼리
```sql
Hibernate: 
    /* delete collection hellojpa.Member.addressHistory */ delete 
        from
            ADDRESS 
        where
            MEMBER_ID=?
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert collection
        row hellojpa.Member.addressHistory */ insert 
        into
            ADDRESS
            (MEMBER_ID, city, street, zipcode) 
        values
            (?, ?, ?, ?)
```
+ DB에 값은 잘 들어갔지만, 진행 쿼리를 보면 delete ADDRESS 쿼리 후에, 두번 insert해주고 있다.
+ 즉 현재 한 멤버(member)의 member_id = ? 인 부분을 다지우고, 남아야하는 o1d2와 , 추가된 new1를 insert하고 있다.
+ 컬렉션은 DB입장 보면 값을 쉽게 찾아내기가 쉽지 않다. 그러므로 이런 방식으로 진행하는데 이렇게 진행되는건 비효율적이며 위험하다.

### 값 타입 컬렉션의 제약사항
+ 값 타입은 엔티티와 다르게 식별자 개념이 없다. 
+ 그러므로 값은 변경하면 추적이 어렵다. 
+ 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 
+ 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키(PK)를 구성해야 함: null 입력X, 중복 저장X
  - 모든 컬럼을 연결하여 PK값을 구성

### 값 타입 컬렉션 대안
+ 위같은 제약사항때문에 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려한다.
+ 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용한다.
+ 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션(= 특징과 유사하게 만들어서) 처럼 사용
> AddressEntitiy 생성
```java
@Entity
@Table(name = "ADDRESS")        // ADDRESS_ENTITIY 대신 ADDRESS로 생성
public class AddressEntitiy {

    @Id
    @GeneratedValue
    private Long id;

    private Address address;                  // Address 값타입을 멤버변수로 가짐.

    public AddressEntitiy() {
    }

    public AddressEntitiy(Address address) {           
        this.address = address;
    }

    public AddressEntitiy(String city, String street, String zipcode) {     // 값 주입을 위한 생성자.
        this.address = new Address(city,street,zipcode);
    }
```
> 일대다 관계 매핑
```java
@Entity
public class Member {
    (...)
//    ---------------------이전의 컬렉션 작업    
    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
            @JoinColumn(name = "MEMBER_ID")) //FK
    @Column(name = "FOOD_NAME")              
    private Set<String> favoriteFoods = new HashSet<>();

//    @ElementCollection
//    @CollectionTable(name = "ADDRESS", joinColumns =
//            @JoinColumn(name = "MEMBER_ID"))    //FK값
//    private List<Address> addressHistory = new ArrayList<>();

//    ---------------------일대 다 관계 매핑
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)       // 컬렉션의 특징(Member 의존적)과 같이 설정
    @JoinColumn(name ="MEMBER_ID")
    private List<AddressEntity> addressHistory = new ArrayList<>();  // 이렇게 해야 활용성도 높고, 쿼리 최적화에도 훨씬 좋은 상태가 된다.
    
        public List<AddressEntity> getAddressHistory() {
        return addressHistory;
    }

    public void setAddressHistory(List<AddressEntity> addressHistory) {
        this.addressHistory = addressHistory;
    }
}
```
> jpaMain
```java
           Member member = new Member();
            member.setUsername("member1");
            member.setHomeAddress(new Address("homeCity","street","10000"));    // 생성자로 값 주입

            em.persist(member);

            member.getAddressHistory().add(new AddressEntity("old1","street","10000"));
            member.getAddressHistory().add(new AddressEntity("old2","street","10000"));
            ==========================================================================
            //여기서 값 수정 내용이없는데.. 시간좀 썻는데 해결이 안되서 미래에 공부해보고 알수 있으면 좋겠다.(old1 -> new1)
```
> 쿼리결과
```sql
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
Hibernate: 
    /* create one-to-many row hellojpa.Member.addressHistory */ update
        ADDRESS 
    set
        MEMBER_ID=? 
    where
        id=?
```
+ 일대 다 연관관계 매핑이면 FK가 '다'쪽에 있으므로, 값을 추가할때 마다 ADDRESS TABLE에 update 쿼리가 나가는 모습을 볼 수 있다.(member값의 변화를 update로 처리)
+ h2 db에 ADDRESS TABLE로 엔티티를 생성하였으므로, 자체적 ID 즉 FK가 생성된 모습을 볼수있다.
+ 그림11
+ 이렇게 해서 엔티티에서 값수정하는 방식으로 해주면 된다. ( 근데 지금 못하겠다..나중에 복습하면서 해보자)

### 정리
+ 엔티티 타입의 특징
    - 식별자O 
    - 생명 주기 관리
    - 공유
+ 값 타입의 특징
    - 식별자X 
    - 생명 주기를 엔티티에 의존
    - 공유하지 않는 것이 안전(복사해서 사용) 
    - 불변 객체로 만드는 것이 안전

### 그럼 결과적으로 언제 컬렉션을 쓰는가?
```
값 타입은 정말 값 타입이라 판단될 때만 사용( 주로 저장만 쓰이는 간단한 작업 )
엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨.
식별자가 필요하고, 지속해서 값을 추적(조회), 변경해야 한다면 그것은 값 타입이 아닌 엔티티
```
