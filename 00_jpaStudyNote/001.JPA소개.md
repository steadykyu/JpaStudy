## 글 기준 방식

1. 목차,강의 의 핵심 내용
2. 기술을 사용하는 이유, 어떻게 활용하는지(why, how)
3. 이해가 안되거나 하는 부분을 내가 이해하는 선으로.(weakness)

# 목차

# 1. 강좌 소개

책을 참고서느낌으로 챙겨보고, 아래 두가지는 꼭 염두하고 공부하자.

1. 객체와 테이블을 알맞게 설정시키고 매핑하는법을 모르면 오히려 시간낭비가 될 수 있다.

2. jpa 내부 동작방식을 이해해야 시간낭비없이 sql에 시간낭비를 줄일 수 있다.

# 2. SQL 중심적인 개발의 문제점

### 1.객체의 움직임 하나하나마다 CRUD(create, read, update, and delete) 과정을 거쳐 무한 반복적이고 지루한 코드만 쳐야하는 상황이 나온다.

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_1.png" width="60%" height="60%">
</p>

### 2.객체에 필드 하나만 추가하더라도 모든 DB에 또 column을 추가해주어야 한다. 결국 SQL에 의존적인 개발을 피하기 어렵다.

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_2.png" width="60%" height="60%">
</p>

### 3.객체지향언어인 Java와 보관하려는 사상을 가진 RDBMS는 사상부터 다르다.

> 객체지향언어 vs RDBMS

```
상속성, 추상화, 캡슐화, 다형성 vs 값 보관에 최우선
```

그래도 현실적인 대안은 데이터베이스밖에 없다. 객체를 관계형 DB에 저장하면 아래 그림과 같이 작업한다.

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_3.png" width="60%" height="60%">
</p>

# 3. 객체 와 RDBMS 의 차이(pt그림참고)

1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법

## 3.1 상속

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_4.png" width="60%" height="60%">
</p>

객체 상속과 가장비슷한 슈퍼타입과 서브타입의 관계를 보자.

DBMS는 상속관계가 없기때문에, 슈퍼테이블과 서브테이블의 외부 pk를 조인한 값을 가져와야 한다. 즉 복잡하다. Album 을 사용한다고 해보자.

> Album 저장

1. 객체 분해
2. INSERT INTO ITEM ...
3. INSERT INTO ALBUM …

> Album 조회

1. 각각의 테이블에 따른 조인 SQL 작성...
2. 또 그에맞는 각각의 객체 생성...
3. 상상만 해도 복잡
4. 더 이상의 설명은 생략한다.
5. **그래서 DB에 저장할 객체에는 상속 관계는 안쓴다.**

> 만약 자바 컬렉션으로 조회한다면?

```
Album album = list.get(albumId);
Item item = list.get(albumId);
부모 타입으로 조회 후 다형성 활용

```

## 3.2 연관관계

객체는 참조를 사용한다. ex) member.getTeam()

테이블은 외래키를 사용한다. ex) JOIN ON M.TEAM_ID = T.TEAM_ID

> 객체를 테이블에 맞추어 모델링할 경우

```java
class Member {
 String id; //MEMBER_ID 컬럼 사용
 Long teamId; //TEAM_ID FK 컬럼 사용 //**
 String username;//USERNAME 컬럼 사용
}

class Team {
 Long id; //TEAM_ID PK 사용
 String name; //NAME 컬럼 사용
}

```

> 테이블에 맞춘 객체를 DB에 저장하기

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_5.png" width="60%" height="60%">
</p>

단순하게 객체 내용대로만 매핑해준 내용이다.

> 객체 다운 모델링 저장하기

```java
class Member {
 String id;
 Team team; //참조로 연관관계를 맺는다. //!!!!!!!!!!!
 String username;

 Team getTeam() {
 return team;
 }
}
class Team {
 Long id;
 String name;
}
```

그런데 객체지향적으로 코드를 설계하고 싶어서 위처럼 Long team 대신 Team team으로 설계 코드를 수정했다.

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_6.png" width="60%" height="60%">
</p>

근데 Team team은 객체의 참조값이지, 직접적인 외래키 값이 아니다. 그러므로 어떻게 코드를 짜서 테이블 TEAM_ID에 member.getTeam().getId()로 외래키 값이 들어가도록 했다고 해보자.

힘들게 객체지향적으로 코드를 작성했으나 문제는 객체를 조회할때 발생한다.

> 객체 모델링 조회

```sql
SELECT M.*, T.*
 FROM MEMBER M
 JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

```java
public Member find(String memberId) {
 //SQL 실행 ...
 Member member = new Member();
 //데이터베이스에서 조회한 회원 관련 정보를 Member 클래스에 모두 입력
 Team team = new Team();
 //데이터베이스에서 조회한 팀 관련 정보를 Team 클래스에 모두 입력
 //이때 team은 join으로 인해, 불어나 있을 것임

 //각각 모든 회원의 팀 관계 설정
 member.setTeam(team); //**
 return member;
```

모든 MEMBER의 ROW를 가진 Member 클래스와 모든 TEAM의 ROW를 가진 Team 클래스를 어떻게 해서든 만들고, 각각 팀관계를 설정해주면 객체지향적으로 만들 수 있었다.

근데 이런 과정들은 너무 생산성이 떨어지는 행위다.(속칭 노가다)

> 객체 모델링, 자바 컬렉션에 관리

```java
list.add(member);

Member member = list.get(memberId);
Team team = member.getTeam();
```

만든 Member클래스를 활용하여 컬렉션을 이용하면 그나마 객체 지향적으로 사용할 수 있게 되었다.

## 3.3 객체 그래프 탐색

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_7.png" width="60%" height="60%">
</p>

- 객체는 자유롭게 객체 그래프를 탐색할 수 있어야한다.

참조값이 있을때 .get()으로 값을 얻는것이 가능해야한다는 의미

- 그러나 실행하는 SQL에 따라 탐색 범위가 결정되어버린다.

```sql
SELECT M.*, T.*
 FROM MEMBER M
 JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

 이라면
 member.getTeam();  //이건 얻을 수 있으나,
 member.getOrder(); //를 얻을 수가 없다.
```

나중에 비즈니스로직에 의해 Member에 Order order 필드가 추가됬다고 하자. 그렇다면 order 값은 null일 것이다. 가져오려면 결국 다시 sql를 까보는 작업이 필요하다.

즉 처음 실행하는 sql에 의존하여 탐색범위가 결정되어 버린다.

그러므로 이는 엔티티 신뢰문제를 발생시킨다.

## 3.4 엔티티 신뢰 문제

```java
public void process() {
 Member member = memberDAO.find(memberId);
 member.getTeam(); //???
 member.getOrder().getDelivery(); // ???
 }
```

- memberDAO의 find가 어떤 SQL방식으로 찾아와서 member에 넣는지 알수 없다.

- 즉 RDB의 코드를 까보지 않는이상 엔티티만으로는 신뢰할수 없다.

어떤 문제 때문에 신뢰할수 없는 것일까

> 모든 객체를 미리 로딩할 수는 없다

- 계층형 구조 (ex member.getOrder().getDelivery();) 가 불가능하다.

- 이말은 객체를 미리 로딩할수 없다는 의미이다. 결국 객체들에 대하여 전부다 메서드를 그리고 join query도 만들어주어야한다.

```
memberDAO.getMember(); //Member만 조회

memberDAO.getMemberWithTeam();//Member와 Team 조회

memberDAO.getMemberWithOrderWithDelivery(); //Member,Order,Delivery 조회
```

<h2 align="center">
계층형 아키텍처 - 진정한 의미의 계층 분할이 어렵다.
</h2>

물리적으로는 어떻게 만들수는 있으나, 논리적으로 계층형 구조라고 볼 수가 없다.
(메서드로 만들어서 결과를 볼수는 있으나, 계층형 구조라고 볼 수는 없음)

## 3.4 비교하기

```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);

member1 == member2;
//같은 ID이지만 new Member(..)로 인해 다른 Member 객체이다.

class MemberDAO {

 public Member getMember(String memberId) {
 String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
 ...
 //JDBC API, SQL 실행
 return new Member(...);
 }
}
```

다른 Member 객체이다.

> 비교하기2 - 자바컬렉션에서 조회

```java
String memberId = "100";
Member member1 = list.get(memberId);
Member member2 = list.get(memberId);

member1 == member2; //같다.
```

이 경우에는 값에 대하여 참조하고 있는것이기 때문에 같다.

sql에서 객체를 다룰때랑 컬렉션에서 객체를 다룰때가 벌써 매우 달라져있음이 느껴진다.

## 3.5 결론

객체답게 모델링 할수록 또다시 새로운 매핑 작업만 늘어난다. ROI가 안나올 정도로 투자한거에 비해 너무 힘든 일만 계속된다.

객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까?

# 4. JPA소개

## 4.1 JPA란?

- Java Persistence API

- 자바 진영의 ORM 기술 표준

## 4.2 ORM?

- Object-relational mapping(객체 관계 매핑)

- 객체는 객체대로 설계

- 관계형 데이터베이스는 관계형 데이터베이스대로 설계

- ORM 프레임워크가 중간에서 매핑

- 대중적인 언어에는 대부분 ORM 기술이 존재

> 동작방식

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_8.png" width="60%" height="60%">
</p>

> JPA는 표준 명세

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_9.png" width="60%" height="60%">
</p>

## 4.3 JPA를 그렇다면 왜 사용해야하는가?

> SQL 중심적인 개발에서 객체 중심으로 개발

> 생산성(코드가 줄어든다)

```
• 저장: jpa.persist(member)
• 조회: Member member = jpa.find(memberId)
• 수정: member.setName(“변경할 이름”)
• 삭제: jpa.remove(member)
```

> 유지보수(필드만 추가하면 됨, SQL은 JPA가 처리)

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_10.png" width="60%" height="60%">
</p>

> 패러다임의 불일치 해결

- 상속(저장,조회기능)
- 연관관계, 객체 그래프 탐색
- 신뢰할수 있는 엔티티, 계층
- JPA와 비교하기( 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장)

> 상속과 연관관계

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_11.png" width="60%" height="60%">
</p>

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_12.png" width="60%" height="60%">
</p>

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_13.png" width="60%" height="60%">
</p>

- 나중에 Member 객체에 필드가 추가되더라도 자유롭에 추가가능

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_14.png" width="60%" height="60%">
</p>

> 성능

1. 1차 캐시와 동일성(identity) 보장
2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
3. 지연 로딩(Lazy Loading)

### 1. 1차 캐시와 동일성(identity) 보장

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_15.png" width="60%" height="60%">
</p>

- 처음은 sql에서 가져오고, 이후에는 1차캐시에서 가져온다.

### 2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)

> INSERT

1. 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
2. JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송

```
transaction.begin(); // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.
//커밋하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다.
transaction.commit(); // [트랜잭션] 커밋
```

> UPDATE 옵션

객체의 값을 수정시

1. UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화
2. 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋

```
transaction.begin(); // [트랜잭션] 시작

changeMember(memberA);  // 수정
deleteMember(memberB);  // 삭제
비즈니스_로직_수행(); //비즈니스 로직 수행 동안은 DB 로우 lock이 걸리지 않는다.

//커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다.
transaction.commit(); // [트랜잭션] 커밋
```

### 3. 지연 로딩(Lazy Loading)

<p align="center">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/1_15.png" width="60%" height="60%">
</p>

> 데이터 접근 추상화와 벤더 독립성

> 표준

<h2 align="center">
ORM은 객체와 RDB두 기둥위에 있는 기술
</h2>

그러므로 힘들겠지만 이 두가지를 전부 다 능숙하게 사용해야한다.
