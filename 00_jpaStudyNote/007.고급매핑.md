>참고 

JdbcSQLSyntaxErrorException가 떠서 H2 DB를 1.4.200 / hibernate 5.4.22.Final 버전으로 사용(pom.xml에서 수정)

## 요약

객체들 사이의 고급적인 매핑방법을 알아보자.

## 1. 상속관계 매핑

슈퍼타입 서브타입 논리 모델이 가장 객체의 상속모델과 비슷하다.

> 주요 애노테이션

+ @Inheritance(strategy=InheritanceType.XXX)
    + JOINED: 조인 전략
    + SINGLE_TABLE: 단일 테이블 전략
    + TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
+ @DiscriminatorColumn(name=“DTYPE”)
+ @DiscriminatorValue(“XXX”)

## 2. Join 전략
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)       // Join 전략
@DiscriminatorColumn              
public abstract class Item {

    @Id
    @GeneratedValue
    private Long id;

    private String name;
    private int price;
    (getter setter)
```
```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
    private String director;
    private String actor;
    (getter setter)
```
InnerJoin을 통해 객체의 상속관계를 표현한다.

Item 객체 상속관계에만 이용하고 값자체를 굳이 사용하지 않는다면 위처럼 추상클래스로 생성하여 사용한다.

> 장단점

(단점)Join을 많이 하여 속도 저하가 있을수 있기는 하지만, (장점)하드웨어의 발달과 객체 상속의 모습을 가장 잘 구현한다는 점에서 가장 일반적으로 사용되는 전략이다.

## 3. 단일 테이블 전략
> 구현

상속하는 슈퍼클래스 엔티티에 @Inheritance(strategy = InheritanceType.SINGLE_TABLE); 만 입력하면 된다.

> 특징

상속관계에 있는 슈퍼타입과 모든 서브타입의 테이블을 outer Join으로 거대한 테이블로 만든후 where 문을 통해 필요한 row들을 가져온다.(DB 확인하면 이해쉬움)

거대한 테이블을 만드는 과정에서 각각의 하위 엔티티들을  구별해주기 위해 자동으로 Dtype column을 만든다.

> 장단점

장점 : 조인이 필요 없으므로 조회 성능이 빠르고 쿼리가 단순하다.

단점 : Outer Join으로 거대한 테이블을 만드는 과정에서 null을 허용하므로 무결성 조건이 제대로 지켜지지않는다. 

## 4. 구현클래스마다 테이블 전략
> 구현

상위 엔티티에 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)

> 특징

각각의 서브타입 테이블에 슈퍼타입의 Column이 모두 들어가도록 테이블을 생성한다.
```
item : id name price
movie : id actor director
...
-> 쿼리 이후의 테이블
movie : id name price actor dir
album : id name price artist
Book : id name price author isbn 
```

> 장단점

+ 장점 
not null 제약조건 사용이 가능하다.

+ 단점

여러개의 서브타입 테이블을 조회시 개별적으로 Union SQL 작업을 하므로 성능이 느리다.

또한 여러 테이블을 사용할 시 변화된 서브테이블을 통합하여 사용하므로 쿼리하기 어렵고 새로운 테이블을 추가하는데 어려움이 있음.

## 5. @MappedSuperclass

상속관계 매핑은 아니다. 그러나 약간 비슷한 점이 정보 제공 목적의 클래스이다.

> 구현
```java
@MappedSuperclass
public abstract class BaseEntity {

    @Column(name = "INSERT_MEMBER")
    private String createdBy;
    private LocalDateTime createdDate;
    private String lastModifiedBy;
    private LocalDateTime lastModifiedDate;
    (getter , setter) (....)
    
===========================================
@Entity
public class Member extends BaseEntity {...}
===========================================
@Entity
public class Team extends BaseEntity {...}
```
주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 매핑정보를 모아서 정보를 제공하는 역할을 한다.

직접 생성해서 사용할 일이 없으므로 추상 클래스 권장한다.

엔티티가 아니기 때문에 엔티티매니저로 조회나 검색이 불가능하다.
***
# 1.상속관계 매핑

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_1.png">

+ 왼쪽의 RDBMS 논리모델 오른쪽의 객체모델
+ 관계형 데이터베이스는 상속 관계X 
+ 슈퍼타입-서브타입 관계라는 DB 모델링 기법이 객체 상속과 유사
+ 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
+ 슈퍼타입-서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
   1. 각각 테이블로 변환 -> 조인 전략
   2. 통합 테이블로 변환 -> 단일 테이블 전략
   3. 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

## 주요 어노테이션
+ @Inheritance(strategy=InheritanceType.XXX) 
    1. JOINED: 조인 전략
    2. SINGLE_TABLE: 단일 테이블 전략
    3. TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
+ @DiscriminatorColumn(name=“DTYPE”) 
+ @DiscriminatorValue(“XXX”)

## 조인 전략
+ 코드작업
> Item
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)       // Join 전략
@DiscriminatorColumn              
public abstract class Item {

    @Id
    @GeneratedValue
    private Long id;

    private String name;
    private int price;
    (getter setter)
```
+ @DiscriminatorColumn : 상속받는 테이블들을 구별해주는 Dtype column을 추가해준다. name = "" 속성으로 Dtype대신 이름설정 가능
+ 입력하지않으면 생략된다.하지만 운영상 이유로 Dtype column 보여주는게 좋다.

> Movie
```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
    private String director;
    private String actor;
    (getter setter)
```
+ @DiscriminatorValue("M") : default로는 TABLE 명이 들어간다. 테이블에 들어가는 값 수정을 위해 사용한다.
> 실행파일(JPAMain) 
```java

            Movie movie = new Movie();
            movie.setDirector("규하");
            movie.setActor("박보영");

            //이름과 price는 Item에 getter setter가 있어야 메서드 호출이 가능능
           movie.setName("바람과 함께 사라지다.");
           movie.setPrice(10000);

            em.persist(movie);
            
            // 쿼리 저장소의 쿼리가 동작한다.
            em.flush();        
            em.clear();

            Movie findMovie = em.find(Movie.class, movie.getId());
            System.out.println("findMovie = " + findMovie);
            // movie table이 item table과 inner join해서 필요한 값을 찾아내는 모습을 확인할수 있다.

            tx.commit();
```
> H2 Table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_3.png">

> 저장시 쿼리
```sql
 create table Item (
       DTYPE varchar(31) not null,
        id bigint not null,
        name varchar(255),
        price integer not null,
        primary key (id)
    )
create table Movie (
       actor varchar(255),
        director varchar(255),
        id bigint not null,
        primary key (id)
    )
    (....)
```
> 조회시 쿼리
```sql
Hibernate: 
    select
        movie0_.id as id2_2_0_,
        movie0_1_.name as name3_2_0_,
        movie0_1_.price as price4_2_0_,
        movie0_.actor as actor1_6_0_,
        movie0_.director as director2_6_0_ 
    from
        Movie movie0_ 
    inner join
        Item movie0_1_ 
            on movie0_.id=movie0_1_.id 
    where
        movie0_.id=?
findMovie = hellojpa.advanced_mapping.Movie@43bf5397
```
+ inner join으로 가져오는 모습

### 조인 정략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_2.png">

> 장점

- 테이블 정규화
- 외래 키를 참조하여 무결성 제약조건 활용가능

> 정규화
```
정규화(Normalization)의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.
```
> 무결성 제약조건
```
데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건

만약 주문테이블에서 FK값을 통해 Item조회시 Item객체만 보면 된다. 다른 추가적인 테이블이나 열들이 나오지 않음.
```
- 저장공간 효율화

> 단점
- 조회시 조인을 많이 사용하여 성능 저하
- 조회 쿼리가 복잡함
- 데이터 저장시 INSERT SQL 2번 호출

단점이 하드웨어의 발달로 요즘에는 크게 안느껴진다.

오히려 객체와 가장 유사한점, 설계에서의 장점등 때문에 조인전략을 정석으로 보는게 좋다.

## 단일 테이블 전략
+ @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 만 추가해주면 된다.
+ @DiscriminatorColumn은 자동으로 생성후 돌아간다. 그래야만 테이블 구별이 가능하기 때문이다.
> 저장시 쿼리
```
    create table Item (
       DTYPE varchar(31) not null,
        id bigint not null,
        name varchar(255),
        price integer not null,
        actor varchar(255),
        director varchar(255),
        artist varchar(255),
        author varchar(255),
        isbn varchar(255),
        primary key (id)
    )
```
+ 단일 테이블을 생성하는 모습
> 조회시 쿼리
```
    select
        movie0_.id as id2_0_0_,
        movie0_.name as name3_0_0_,
        movie0_.price as price4_0_0_,
        movie0_.actor as actor5_0_0_,
        movie0_.director as director6_0_0_ 
    from
        Item movie0_ 
    where
        movie0_.id=? 
        and movie0_.DTYPE='M'
findMovie = hellojpa.advanced_mapping.Movie@77ab22be
```
+ Item 에서만 찾음
> H2 table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_4.png">

### 단일 테이블 전략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_5.png">

+ 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
+ 단점
    - 거대한 테이블을 제작하므로 자식 엔티티가 매핑한 컬럼은 모두 null 허용(무결성입장에서 애매함)
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

+ 최근 테이블이 커져서 느려지는 임계점이 생각보다 잘 오지는 않음.

## 구현클래스마다 테이블 전략
> 코드작업
+ @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) 만 Item에서 수정한다.
+ public abstract class Item {...}
```
 - 추상 클래스로 생성시 item Table 생성없이 속성값이 들어간다.
 - Item 테이블이 꼭 필요할때만 Item을 추상클래스로 안만들면된다.
```
> 저장시 쿼리
```
    create table Movie (
       id bigint not null,
        name varchar(255),
        price integer not null,
        actor varchar(255),
        director varchar(255),
        primary key (id)
    )
    ... Album, Book table 생성
```
> 조회시 쿼리
```
    select
        movie0_.id as id2_0_0_,
        movie0_.name as name3_0_0_,
        movie0_.price as price4_0_0_,
        movie0_.actor as actor5_0_0_,
        movie0_.director as director6_0_0_ 
    from
        Item movie0_ 
    where
        movie0_.id=? 
        and movie0_.DTYPE='M'
findMovie = hellojpa.advanced_mapping.Movie@77ab22be
```
+ 모든 column이 다있는 Item 쿼리에서 가져옴.

+ Item의 name과 price 속성값이 들어가 있는 모습을 볼 수 있다.

> H2 Table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_6.png">

### 구현 클래스마다 테이블 전략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_7.png">

+ 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X 
+ 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능(테이블 null이 없게 만들 수 있음)
+ 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) 
    - 자식 테이블을 통합해서 쿼리하기 어려움
    - 새로운 테이블 추가시 복잡해짐.

> 조회시 쿼리
```
Movie, Album, Book 3개의 테이블을 union한 테이블을 생성후 조회함.
```

## 참고
+ 재미있는 장점으로 그저 어노테이션만 바꿨는데 전략 변경이 가능한 모습을 볼 수 있다.
+ 조인 전략의 장단점, 단일 테이블의 장단점을 DBA와 비교하면서 작업하면 된다.
+ 강사님은 매우 단순한 타입이고, 확장할 일이 없을때 단일테이블로 제작하고 비즈니스적으로 중요하면 조인전략을 사용하시는 편이다.

# 2. MappedSuperclass

우리는 이전의 Member 와 Team 엔티티를 완성했었다.

그런데 이전에 제작해둔 엔티티에 코드 수정을  누가했는지 ,언제했는지 기록하는 필드를 추가하자는 내용이 나왔다. 그럴 때는 어떻게 작업해야할까?

> 코드작업
```java
// 매핑 정보만 받도록 하는 클래스라고 선언
@MappedSuperclass
public abstract class BaseEntity {

    @Column(name = "INSERT_MEMBER")
    private String createdBy;
    private LocalDateTime createdDate;
    private String lastModifiedBy;
    private LocalDateTime lastModifiedDate;
    (getter , setter) (....)
    
===========================================
@Entity
public class Member extends BaseEntity {...}
===========================================
@Entity
public class Team extends BaseEntity {...}
```
> 날라간 쿼리
```sql
    create table Member (
       MEMBER_ID bigint not null,
        INSERT_MEMBER varchar(255),
        createdDate timestamp,
        lastModifiedBy varchar(255),
        lastModifiedDate timestamp,
        USERNAME varchar(255),
        LOCKER_ID bigint,
        TEAM_ID bigint,
        primary key (MEMBER_ID)
    )
======================================
    create table Team (
       TEAM_ID bigint not null,
        INSERT_MEMBER varchar(255),
        createdDate timestamp,
        lastModifiedBy varchar(255),
        lastModifiedDate timestamp,
        name varchar(255),
        primary key (TEAM_ID)
    )
```
+ BaseEntity에서 선언해둔 필드값들이 상속받는 모든 엔티티에 들어갔다.

## @MappedSuperclass 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_8.png">

+ 상속관계 매핑X (아니다.)
+ 엔티티X, 테이블과 매핑X (아니다.)
+ 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공

+ 그러므로 조회, 검색 불가(em.find(BaseEntity) 불가)

+ 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

+ 테이블과 관계 없고, 단순히 엔티티끼리 공통으로 사용하는 매핑정보를 모으는 역할

+ 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 **공통으로 적용하는 정보**를 모을 때 사용
+ 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스 둘 중 한개만 상속(extends) 가능

## 참고
+ 참고로 이런 수정정보는 JPA의 이벤트기능으로 자동화 할 수 있다.
+ 위와같은 수정사항 기록은 immutable 테이블만 아니라면 일반적으로 깔아주어야 운영측면에서 매우 좋다.


### 4. 실전
+ 실무에서의 상속으로 얻은 장단점
```
정답이 있는 문제는 아니지만, APP 크기가 적당하면 상속관계를 사용하는 것이 괜찮다.(코드 낭비 측면, 설계측면)
그러나 엄청나게 트래픽이 오는 상황에서는 테이블을 최대한 단순하게 만들어야한다.
그러므로 상속받아야할 테이블들은 상속 설정 대신 json으로 말아넣는 경우가 있다.
```
