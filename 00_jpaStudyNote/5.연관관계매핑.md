# 요약

# 연관관계 매핑 기초

## 연관관계가 필요한 이유
+ 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. 즉 객체지향 설계를 위해서 필요하다.

## 예제 시나리오
```
• 회원과 팀이 있다. 
• 회원은 하나의 팀에만 소속될 수 있다. 
• 회원과 팀은 다대일 관계다
```

## 1.객체를 테이블에 맞추어 모델링
+그림1
+ FK(외래키)가 존재한다는 것은 한 FK에 여러 PK가 있을수 있다는 뜻이다.(TeamA : Member1, Member2)
+ 즉 1대 N의 관계라는 것이다.

### 코드작업
> 멤버
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

      @Column(name = "TEAM_ID")
    private Long teamId;
    
    (+ getter , setter)
```
> 팀
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;
    (+ getter , setter)
```
> 실행파일
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeamId(team.getId());                             // 외래키값을 직접 저장
            em.persist(member);

            Member findMember = em.find(Member.class, member.getId());  // 값 조회 / id=1이 들어가있음
            Long findTeamId  = findMember.getTeamId();                  // 외래키값을 꺼냄.

            Team findTeam = em.find(Team.class, findTeamId);            // 외래키값으로 조회
            findTeam.getId();                                           // 팀의 아이디를 얻음.
            tx.commit();
            (....)
```
+ 외래 키 식별자를 직접 다루어 저장한다.
+ 조회 하려고 하면 외래키 식별자(getTeamId() -> team_id)구해야 하고, 그대로의 값으로 사용한다는 단점이 있다.
+ id=1인 member의 팀의 id 그리고 이름을 얻기위해서는 JPA를 거쳐 DB에서 두번이나 find()해와야한다.
> 결국 **협력관계**를 만들수 없다.
```
• 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다. 
• 객체는 참조를 사용해서 연관된 객체를 찾고있다.
     - 그런데 위코드는 참조가 아닌 외래키를 값을 직접 구해서 연관 테이블을 찾고있다.
• 테이블과 객체 사이에는 이런 큰 간격이 있다.
```
## 2.단방향 연관관계
+ 그림2

> 멤버
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
```
+ Member 입장에서 Team과 N:1이므로 @ManyToOne을 추가하여 JPA와 DB에 관계를 알려준다.
+ 그리고 team 참조값과 TEAM_ID(FK)를 @JoinColumn(name = "TEAM_ID")으로 매핑시켜준다. 
+ DB에서 MEMBER와 TEAM 테이블을 Join 시켜주는 컬럼을 알려준다.
+ JPA에서 애노테이션들은 거의 다 DB에게 옵션이나 값을 지정해주는 역할을 한다.

> 실행
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        // 관리자를 새로 만들기.(아래 코드입장에서는 계속 em과 트랜잭션이 새로 만들어 지는 것이다.)
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);                   // 단방향 연관관계 설정, 참조 저장                                  
            em.persist(member);                     // JPA가  자동으로 team에서 pk값을 꺼낸후, FK값을 insert할때 FK값으로 사용한다.
            
            em.flush();                             // 쿼리를 DB에 보낸다.
            em.clear();                             // 영속성 컨테이너를 비워준다.
           
            Member findMember = em.find(Member.class, member.getId());
            Team findTeam  = findMember.getTeam();                    // 참조를 통해 연관된 객체를 찾는모습
            System.out.println("findTeam = " + findTeam.getName());   // findTeam 참조변수를 통해 팀의 이름(TeamA)를 얻어옴.
            tx.commit() 
            ...
```
+ 저장 : member.setTeam(team); 을 통해 (Team객체를 참조하는)참조값 저장이 가능하다.
+ flush() : 원래는 1차캐시에서 값을 가져오고 커밋후 쿼리를 날리지만, flush()와 clear를 하면 커밋 전에 쿼리를 DB에 날리고, 영속성 컨테이너의 값을 지울 수 있다.
> 날린 쿼리를 살펴보자.
```
Hibernate: 
    select
        member0_.MEMBER_ID as MEMBER_I1_0_0_,
        member0_.TEAM_ID as TEAM_ID3_0_0_,
        member0_.USERNAME as USERNAME2_0_0_,
        team1_.TEAM_ID as TEAM_ID1_1_1_,
        team1_.name as name2_1_1_ 
    from
        Member member0_ 
    left outer join
        Team team1_ 
            on member0_.TEAM_ID=team1_.TEAM_ID 
    where
        member0_.MEMBER_ID=?
```
+ Join TABLE을 생성하는 쿼리를 날리는 모습을 볼 수 있다.
+ 조회 : 이전과 다르게, member값 찾을때 DB에서 조회하는데, findMember참조변수를 통해 team객체값을 얻어올 수 있다.
+ 마치 연결된 DB에서 값을 가져오듯이 findMember가 가리키는  Member객체안에 Team 객체가 저장되어있다.
+ 결론적으로 테이블끼리 FK로 연결되어 JOIN TABLE을 만든 것을 객체의 참조방식으로 구현한 것이다.
## 3. 연관관계 수정
```java
           // ---------------------------연관관계 수정
            Team team2 = new Team();
            team2.setName("TeamB");
            em.persist(team2);
            findMember.setTeam(team2);                // 기존의 findMember의 연관관계가 수정된다.
            Team findTeam2  = findMember.getTeam();                   // TeamA였던 findMember는 이제
            System.out.println("findTeam = " + findTeam2.getName());  // TeamB 로 출력된다.
```
+그림3

+ findMember, MEMBER TALBE에 존재하는 row는 TEAM_ID가 1에서 3으로 변경된 것이다.
+ TEAM_ID를 통해 JOIN하여 그 안의 NAME을 꺼내오는 과정을 객체 참조의 과정으로 만들어 내고 있다.
