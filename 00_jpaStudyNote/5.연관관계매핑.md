# 요약

# 1.연관관계 매핑 기초

## 연관관계가 필요한 이유
+ 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. 즉 객체지향 설계를 위해서 필요하다.

## 예제 시나리오
```
• 회원과 팀이 있다. 
• 회원은 하나의 팀에만 소속될 수 있다. 
• 회원과 팀은 다대일 관계다
```

## 1.1객체를 테이블에 맞추어 모델링
+그림1
+ FK(외래키)가 존재한다는 것은 한 FK에 여러 PK가 있을수 있다는 뜻이다.(TeamA : Member1, Member2)
+ 즉 1대 N의 관계라는 것이다.

### 코드작업
> 멤버
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

      @Column(name = "TEAM_ID")
    private Long teamId;
    
    (+ getter , setter)
```
> 팀
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;
    (+ getter , setter)
```
> 실행파일
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeamId(team.getId());                             // 외래키값을 직접 저장
            em.persist(member);

            Member findMember = em.find(Member.class, member.getId());  // 값 조회 / id=1이 들어가있음
            Long findTeamId  = findMember.getTeamId();                  // 외래키값을 꺼냄.

            Team findTeam = em.find(Team.class, findTeamId);            // 외래키값으로 조회
            findTeam.getId();                                           // 팀의 아이디를 얻음.
            tx.commit();
            (....)
```
+ 외래 키 식별자를 직접 다루어 저장한다.
+ 조회 하려고 하면 외래키 식별자(getTeamId() -> team_id)구해야 하고, 그대로의 값으로 사용한다는 단점이 있다.
+ id=1인 member의 팀의 id 그리고 이름을 얻기위해서는 JPA를 거쳐 DB에서 두번이나 find()해와야한다.
> 결국 **협력관계**를 만들수 없다.
```
• 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다. 
• 객체는 참조를 사용해서 연관된 객체를 찾고있다.
     - 그런데 위코드는 참조가 아닌 외래키를 값을 직접 구해서 연관 테이블을 찾고있다.
• 테이블과 객체 사이에는 이런 큰 간격이 있다.
```
## 1.2 단방향 연관관계
+ 그림2

> 멤버
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
```
+ Member 입장에서 Team과 N:1이므로 @ManyToOne을 추가하여 JPA와 DB에 관계를 알려준다.
+ 그리고 team 참조값과 TEAM_ID(FK)를 @JoinColumn(name = "TEAM_ID")으로 매핑시켜준다. 
+ DB에서 MEMBER와 TEAM 테이블을 Join 시켜주는 컬럼을 알려준다.
+ JPA에서 애노테이션들은 거의 다 DB에게 옵션이나 값을 지정해주는 역할을 한다.

> 실행
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        // 관리자를 새로 만들기.(아래 코드입장에서는 계속 em과 트랜잭션이 새로 만들어 지는 것이다.)
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);                   // 단방향 연관관계 설정, 참조 저장                                  
            em.persist(member);                     // JPA가  자동으로 team에서 pk값을 꺼낸후, FK값을 insert할때 FK값으로 사용한다.
            
            em.flush();                             // 쿼리를 DB에 보낸다.
            em.clear();                             // 영속성 컨테이너를 비워준다.
           
            Member findMember = em.find(Member.class, member.getId());
            Team findTeam  = findMember.getTeam();                    // 참조를 통해 연관된 객체를 찾는모습
            System.out.println("findTeam = " + findTeam.getName());   // findTeam 참조변수를 통해 팀의 이름(TeamA)를 얻어옴.
            tx.commit() 
            ...
```
+ 저장 : member.setTeam(team); 을 통해 (Team객체를 참조하는)참조값 저장이 가능하다.
+ flush() : 원래는 1차캐시에서 값을 가져오고 커밋후 쿼리를 날리지만, flush()와 clear를 하면 커밋 전에 쿼리를 DB에 날리고, 영속성 컨테이너의 값을 지울 수 있다.
> 날린 쿼리를 살펴보자.
```
Hibernate: 
    select
        member0_.MEMBER_ID as MEMBER_I1_0_0_,
        member0_.TEAM_ID as TEAM_ID3_0_0_,
        member0_.USERNAME as USERNAME2_0_0_,
        team1_.TEAM_ID as TEAM_ID1_1_1_,
        team1_.name as name2_1_1_ 
    from
        Member member0_ 
    left outer join
        Team team1_ 
            on member0_.TEAM_ID=team1_.TEAM_ID 
    where
        member0_.MEMBER_ID=?
```
+ Join TABLE을 생성하는 쿼리를 날리는 모습을 볼 수 있다.
+ 조회 : 이전과 다르게, member값 찾을때 DB에서 조회하는데, findMember참조변수를 통해 team객체값을 얻어올 수 있다.
+ 마치 연결된 DB에서 값을 가져오듯이 findMember가 가리키는  Member객체안에 Team 객체가 저장되어있다.
+ 결론적으로 테이블끼리 FK로 연결되어 JOIN TABLE을 만든 것을 객체의 참조방식으로 구현한 것이다.
## 1.3 연관관계 수정
```java
           // ---------------------------연관관계 수정
            Team team2 = new Team();
            team2.setName("TeamB");
            em.persist(team2);
            findMember.setTeam(team2);                // 기존의 findMember의 연관관계가 수정된다.
            Team findTeam2  = findMember.getTeam();                   // TeamA였던 findMember는 이제
            System.out.println("findTeam = " + findTeam2.getName());  // TeamB 로 출력된다.
```
+그림3

+ findMember, MEMBER TALBE에 존재하는 row는 TEAM_ID가 1에서 3으로 변경된 것이다.
+ TEAM_ID를 통해 JOIN하여 그 안의 NAME을 꺼내오는 과정을 객체 참조의 과정으로 만들어 내고 있다.

# 2. 양방향 연관관계와 연관관계의 주인-기본
+ 위에서  Member객체에서 Team으로는 갈수 있는데, 반대로 Team에서도 Member객체로 가게 해주고싶다.
+ 그럴때 객체는 양방향 매핑을 사용하면 된다.
+ 그림4
## 1.테이블 연관관계
```
- 테이블 연관관계에서 MEMBER에서 TEAM을 얻고싶으면 TEAM_ID로 JOIN하면 되고, 반대로 TEAM에서 MEMBER를 알고 싶어도 JOIN하면된다.
- 멤버가 어떤팀인지 알고싶은거랑, 팀에 어떤멤버가있는지는 둘다 테이블JOIN을 하면 구할 수 있다.
- 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
- MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐(양방향이긴 하지만 사실 없는 느낌이 강함)
```
## 2.객체 연관관계
```
- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단뱡향 관계 2개다.
```
### 코드작업
> Team에 매핑 추가
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")                     // Team입장에선 1대n관계
    private List<Member> members = new ArrayList<>(); // 관례로 이렇게 초기화함.
    (....getter setter)
```
+ mappedBy
``` 
- 멤버 변수가 반대편 객체에서 매핑하고 있는 변수를 넣어준다.
- 양방향 매핑일 경우 매핑을 담당하는 반대쪽 참조변수가 들어가면 된다.
```
> 실행
```
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);   
            em.persist(member);

            em.flush();
            em.clear();

            Member findMember = em.find(Member.class, member.getId());
            List<Member> members = findMember.getTeam().getMembers();       // 역방향 
            for(Member m : members){
                System.out.println("m = "+ m.getUsername());
            }

            tx.commit();
```
+ 결과 m = member1;

### 둘 중 하나로 외래키를 관리해야한다.
+그림5
```
즉 만약 한 멤버가 팀을 바꾸고 싶은 상황이라면, team을 수정해야할까 아니면 members를 수정해야할까 고민이 생긴다.
둘다 맞는말이나 db는 그저 fk만 잘 수정되면 된다. 근데 외래키는 어떻게 업데이트 해야할까?
```

## 3. 연관관계의 주인-Owner
### 양방향 매핑 규칙
```
• 객체의 두 관계중 하나를 연관관계의 주인으로 지정
• 연관관계의 주인만이 외래 키를 관리(등록, 수정) 
• 주인이 아닌쪽은 읽기만 가능
• 주인은 mappedBy 속성 사용X 
• 주인이 아니면 mappedBy 속성으로 주인 지정
```

### 누구를 주인으로?
+ 그림6
+ 여기서는 Member.team이 연관관계의 주인이다.
+ 즉 Team의 members는 값을 조회만 가능하지, 값 등록, 수정이 불가능하다.
+ ***외래 키가 있는 있는 곳을 주인으로 정해라***
> 이유
```
1. DB입장에서 보면 외래키가 있는 곳이 무조건 N, 아닌쪽이 1이다. 이말은 DB N쪽이 연관관계 주인이 된다는 것이다.(ManytoOne 쪽)
2. 연관관계의 주인은 비즈니스적으로는 도움되지는 않는다.
     ex) 자동차와 바퀴중 자동차가 비즈니스적으로 중요한데, 바퀴가 연관관계 주인이 되어야한다.
3. Member 객체값을 바꾸면 MEMBER테이블 FK가 바뀌므로 설계가 깔끔해진다.
4. 만약 반대로 members가 주인이라면 members 수정시 다른 테이블인 MEMBER에 쿼리가 나간다. 
   이는 복잡한 상황을 만들뿐더러, 성능 저하도 일으킨다.
```
