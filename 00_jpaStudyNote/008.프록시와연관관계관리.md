## 요약

JPA에서는 프록시의 동작방식으로 즉시로딩과 지연로딩을 사용된다. 한 엔티티와 자주 사용되는 엔티티를 함께 생성시키는 쿼리를 출력하거나, 사용시에만 엔티티를 생성하는 쿼리를 출력하도록 할수 있다.

영속성 전이(CASCADE)와 고아객체를 활용하면 특정 엔티티와 단일 소유자 관계의 엔티티가 존재할때, 소유자 엔티티의 참조변수를 통해 엔티티 객체의 값들을 조금 더 편리하게 영속화 하고 제거할수 있다.

## 1. 프록시

영속성 컨테이너에 저장되어 있는 엔티티 객체를 레퍼런스로 가져오는 것 대신 엔티티 객체에 존재하는 값을 메서드로 호출해서 가져와 주는 프록시라는 개념이 존재한다.

이는 즉시로딩과 지연로딩을 동작시키게 만들어 준다. 이점을 유의하며 보자.

### 특징 및 사용하는 이유

1. 영속성 컨테이너에 존재하는 엔티티를 상속하고 있다.

   - (proxy instanceOf Entitiy)

```java
Member m1 = em.find(Member.class, member1.getId());           // 엔티티객체를 의미
Member m2 = em.getReference(Member.class, member2.getId());   // 프록시를 의미
System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // (false-엔티티와 프록시)

// 대신 이런식으로 비교가능(true)
System.out.println("m1 == m2 : " + (m1 instanceof Member));
System.out.println("m1 == m2 : " + (m2 instanceof Member));
```

2. 프록시 객체는 실제 객체의 참조변수를 보관하고 있다. 만약 영속성 컨테이너에 엔티티가 존재하지 않으면 참조변수를 이용하여 엔티티를 참조하고 값을 가져온다.

3. JPA는 처음 프록시로 객체를 만든다면 이후로 생성한 객체들을 프록시 타입으로 만들고, 처음 엔티티로 생성한다면 이후로 생성한 객체를 모두 엔티티 타입으로 만든다.

```java
Member refMember = em.getReference(Member.class, member1.getId());      // 프록시 생성
 Member findMember = em.find(Member.class, member1.getId());  // 레퍼런스값이 프록시가 들어가, 프록시에서 참조하여 엔티티 값을 가져오도록 한다.
--------------------------------------------------------
Member findMember = em.find(Member.class, member1.getId());  // 엔티티 생성
Member refMember = em.getReference(Member.class, member1.getId());      // 프록시를 이용하지 않고 엔티티가 레퍼런스값으로 들어간다.
```

이를 통해 JPA 동작이 무난하게 흘러가도록 한다.

### how?

> 구현

```java
            Member member = new Member();
            member.setUsername("hello");

            em.persist(member);

            em.flush(); // 커밋전에 쿼리를 출력한다.
            em.clear();

            Member findMember = em.getReference(Member.class, member.getId());              // find() 대신 getReference
            System.out.println("findMember = " + findMember.getClass());
            System.out.println("findMember = " + findMember.getId());
            System.out.println("findMember = " + findMember.getUserName());     // 쿼리생성
            System.out.println("findMember = " + findMember.getUserName());     // 쿼리생성 X
```

> getid()

getReference에 id가 있으므로, 영속성 컨테이너 에서 값을 가져온다.

> getUserName()

영속성 컨테이너에 값이 존재하지 않으므로 쿼리를 날린다.

```
 DB조회
-> 영속성 컨테이너에 엔티티객체 생성
-> 프록시가 해당 엔티티를 참조하여 getUsername()호출
```

한번 참조되면 영속성 컨테이너에서 값을 찾아오므로, DB쿼리를 날리지 않는다.

## 2. 즉시로딩과 지연로딩

### why?

```java
public void printUser(String memberId) {
 Member member = em.find(Member.class, memberId);
 Team team = member.getTeam();
 System.out.println("회원 이름: " + member.getUsername());  // 영속성 컨텍스트에 존재하는 MEMBER에서 조회 가능함.
 //System.out.println("소속팀: " + team.getName());
}
```

Member 엔티티를 생성하면서 동시에 Team 엔티티도 생성할 필요가 있을때도 있고 Team엔티티를 생성할 필요가 없을때가 있다.

예를들어 회원만 출력하고 싶다고 가정하자. 쿼리를 통해 Team엔티티에 TEAM 테이블 값을 넣어둘 필요가 없다. 오히려 자원의 낭비일 것이다.

상황에 맞는 설정을 해주기 위해 즉시 로딩와 지연로딩을 구별할줄 알아야 한다.

### how?

> 지연로딩 LAZY

```java
@Entity
public class Member extends BaseEntity {
     ....

    @ManyToOne(fetch = FetchType.LAZY) // 지연로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

Member를 조회할때(find()) Member만 쓰고 Team을 동시에 조회시키지 않을때 사용한다.

이때 지연로딩 LAZY를 이용하여 Member의 참조변수 team을 프록시로 만든다.

team참조변수를 사용할때만 프록시를 초기화해준다.

- DB조회 - Team 엔티티 생성 - 참조를 통해 값을 참조

> 즉시로딩 EAGER

```java
@Entity
public class Member extends BaseEntity {
     ....

    @ManyToOne(fetch = FetchType.EAGER) // 즉시로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

Member 조회시(find()), Member와 Team을 Join해서 table에서 필요한 값을 select 해오는 모습을 볼 수 있다.

이때 team에는 프록시가 아닌 영속성 컨테이너 속 엔티티자체를 넣어준다.

수십개의 엔티티들이 서로 연결되어 있으면 여러번의 Join으로 인해 DB성능이슈가 발생한다.

### 실무적 관점

가급적 지연로딩만 사용하자.

즉시로딩은 DB성능 저하와 JPQL 사용시 N+1 문제를 일으킬 수 있다.

- N+1문제는 지연로딩과 fetch join으로 해결하자.

특히 즉시로딩이 default로 설정되있는 애노테이션을 주의하자.

- @ManyToOne, @OneToOne은 defalut가 즉시 로딩이다. -> LAZY로 설정해주자.
- @OneToMany, @ManyToMany는 default가 지연 로딩이다.

## 3. 영속성 전이(CASCADE)와 고아 객체

### CASCADE WHY?

다대일 관계의 엔티티가 존재한다고 가정하자. EX) 자식 : 부모 = n:1

부모엔티티를 영속성 컨테이너에 생성할때 자식엔티티도 생성하여 이 둘의 lifecycle을 맞추려는 의도로 사용한다.(저장되면 저장, 삭제되면 삭제)

### CASCADE HOW?

```java
@Entity
public class Parent {
    @Id
    @GeneratedValue
    private Long id;

    private String name;

    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)      // 추가
    private List<Child> childList = new ArrayList<>();

    public void addChild(Child child){                                  //양방향 매핑의 편의메서드
        childList.add(child);
        child.setParent(this);
    }
    --------------
    // - 트랜잭션 속
    em.persist(parent);              //parent를 영속화하는데, child List속 엔티티들을 전부 영속화 해버린다.
//            em.persist(child1);
//            em.persist(child2);
```

1의 입장에 있는 엔티티에서 @OneToMany(cascade=)을 추가해주면된다.

영속화를 자동으로 해주는 것뿐 연관관계에 영향을 끼치는 것은 없다.

> 종류

- **ALL: 모두 적용**
- **PERSIST: 영속만**
- **REMOVE: 삭제만**
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

### 고아 객체

> Why?

참조가 제거된 엔티티는 다른 곳에서 참조하지 않을때, 고아 객체로 보고 삭제하는 기능이다.

부모 엔티티와 자식 엔티티가 단일 소유자 관계(부모엔티티만 자식을 참조함)일때,부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다.

만약 영속성 컨테이너에서 부모엔티티를 제거할 시 자식엔티티도 함께 제거된다.

Cascade와 마찬가지로 부모가 자식의 lifecycle을 통제하기 위해 사용된다.

> how?

```java
class Parent{

@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST, orphanRemoval = true)
private List<Child> childList = new ArrayList<>();

}
```

- 트랜잭션 속

```java
            Parent findParent = em.find(Parent.class, parent.getId());
            findParent.getChildList().remove(0);
```

고아 객체 제거 : 자식 엔티티를 컬렉션에서 제거하면, Delete 쿼리를 날려 DB에서 Child row하나가 사라진다.

@OneToOne, @OneToMany만 사용 가능하다.

---

# 1.프록시

## 프록시 기초

- em.find() vs em.getReference()
- em.find(): 데이터베이스를 통해서 **실제 엔티티를 객체에** 조회
- em.getReference(): **가짜(프록시)를 생성하고, 필요시 엔티티 객체 조회**함으로써 데이터베이스 조회를 미룬다.
  <img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_1.png">

getId()와 getName() 으로 조회해올 수 있다.

> getReference

```java
            Member member = new Member();
            member.setUsername("hello");

            em.persist(member);

            em.flush(); // 커밋전에 쿼리를 출력한다.
            em.clear();

//            Member findMember = em.find(Member.class, member.getId());
            Member findMember = em.getReference(Member.class, member.getId());              // find 대신 getReference

//            System.out.println("findMember.getId() = " + findMember.getId());             // 쿼리 생성x
//            System.out.println("findMember.getUsername() = " + findMember.getUsername()); // join 쿼리 생성
            System.out.println("findMember = " + findMember.getClass());                    // findMember = class hellojpa.Member$HibernateProxy$lVigPKrS
```

- 위 코드의 getReference를 만들었을때는 프록시 껍데기만 만들었기때문에, 쿼리를 생성하지 않는다.
- 우리가 getReference() 할때 id값을 넣어주었었다. 그러므로 id만 사용시에는 DB에서 쿼리로 조회하지 않고 영속성 컨텍스트에서 값을 조회한다.
- getUsername()을 사용할 시에는 DB에 있는 Username을 찾아오기 위해, DB에 쿼리를 날린다. 생성된 Member 엔티티의 값을 프록시가 참조해 오는 로직이다.
  - (디테일하게는 아래 프록시 객체의 초기화를 참고하자)
- getClass()로 프록시 주소를 알수 있다.

## 프록시 특징

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_2.png">

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상-JPA가 그렇게 구현해 두었다.)

---

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_3.png">

- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

## 프록시 객체의 초기화

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_4.png">

- MemberProxy에 target에 Name값이 없으므로 초기화를 요청한다.
- 이후 DB에서 조회해와서(select 쿼리가 생성), 참조변수 target이 Member 엔티티를 가리키도록 만든다.
- 한번 초기화하면 이제 target참조변수에서 엔티티를 가리키고 있기때문에 추가로 초기화 하지않아도 된다.

## 프록시의 특징 심화

- 프록시 객체는 처음 사용할 때 한 번만 초기화

```java
(위 코드에서 추가작업...)
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리생성
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리를 생성하지않음.
==========================================================
 - 두번 사용해도 한번만 초기화하면 프록시의 참조로 영속성 컨텍스트에 존재하는 원본 엔티티에서 값을 찾아올 수 있다.
```

- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

```java
System.out.println("beforefindMember = " + findMember.getClass());    // beforefindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
System.out.println("findMember.getUsername() = " + findMember.getUsername());
System.out.println("afterfindMember = " + findMember.getClass());     // afteffindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
==============================================
 - 초기화 전, 후 같은 프록시 값을 가지고 있다.
```

- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용)

```java
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("member2");
            em.persist(member2);

            em.flush();
            em.clear();
// -------------------------1. 두 참조변수가 find로 엔티티를 조회했을 경우
//            Member m1 = em.find(Member.class, member1.getId());
//            Member m2 = em.find(Member.class, member2.getId());
//            System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // 같은 엔티티이므로 같은타입이다.

// -------------------------2. 참조변수가 각각의 엔티티, 프록시를 조회했을 경우
            Member m1 = em.find(Member.class, member1.getId());           // 엔티티객체를 의미
            Member m2 = em.getReference(Member.class, member2.getId());   // 프록시를 의미
            logic(m1,m2);
======================================================
    private static void logic(Member m1, Member m2) {
        // System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // (false)다른타입이다.(객체와 프록시)

        // m1, m2가프록시값이든, 객체값이든 일치
        System.out.println("m1 == m2 : " + (m1 instanceof Member)); // 이런식으로 비교가능(true)
        System.out.println("m1 == m2 : " + (m2 instanceof Member)); // 이런식으로 비교가능(true)
    }
```

- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다.

> 선엔티티 후 프록시

```java

            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member m1 = em.find(Member.class, member1.getId());

            Member reference = em.getReference(Member.class, member1.getId());
            System.out.println("reference.getClass() = " + reference.getClass());  // reference.getClass() = class hellojpa.Member
            System.out.println("a == a" + (m1 == reference));
            //reference가 프록시가 아닌 Member엔티티로 나온다.
```

> 근거

```
이유1 : 어차피 Member 원본이 1차 캐시(영속성 컨텍스트)에 등록되어있으므로 엔티티 자체를 가져오면 더 편하게 사용할 수 있다.

이유2 : JPA속 한 트랜잭션안의 영속성 컨텍스트는 m1이 객체든 프록시든 일치하게 만들도록 작동한다.
       (여러 참조변수로 자바 컬렉션 안쪽 같은 객체를 참조하더라도, 두 참조변수는 일치하는 로직을 가지는 것과 비슷하다.)
================================================================================================================================================
만약 위 참조변수 m1과 reference가 둘다 em.getReference()로 작성한다고 해보자.
JPA 로직에 따라 둘다 프록시 Class를 가지며, 영속성컨텍스트에서 == 관계를 가진다.
================================================================================================================================================
```

- 만약 반대순서로 프록시가 먼저 만들어지고 초기화를 작업하면 어떻게 될까?
  > 선프록시 , 후엔티티

```java
 Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("m1 = " + refMember.getClass());             //proxy ( class hellojpa.Member$HibernateProxy$YO93aEu4)

            Member findMember = em.find(Member.class, member1.getId());     // 프록시가 초기화 된다.
            System.out.println("reference.getClass() = " + findMember.getClass()); class hellojpa.Member$HibernateProxy$YO93aEu4
            System.out.println("a == a" + (refMember == findMember));       // true
```

> 해석

프록시가 초기화 됨에도 불구하고 **둘다 프록시**로 반환이 된다.

즉 프록시의 참조를 통해 엔티티조회를 한다면 이후로는 프록시의 참조를 통해 엔티티조회를 하는것이다.

결국 JPA가 한번 프록시로 조회시 계속 프록시로, 엔티티로 조회시 계속 엔티티로 객체가 생성되게 만든다. 그러므로 개발에는 문제가 없도록 작동시킨다.

- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
  (하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)

```java
//            ==================== 준영속 상태일때
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("refMember = " + refMember.getClass());             //proxy생성

//            =================준영속상태로 만드는 작업들===========
            em.detach(refMember); // 영속성컨테이너에서 제외
//            em.close();
//            em.clear();

            System.out.println("refMember = " + refMember.getUsername()); // 초기화작업
```

> 해석

```
try-catch문으로 e.printStackTrace(); 예외를 통해 살펴보자.

LazyInitializationException : could not initialize proxy 가 뜬다.

준영속상태이기 때문에 영속성 컨텍스트의 도움을 받지 못하므로 값을 가져오지 못한다.(실무에서 매우 많이 일어남)
```

## 프록시 확인

위의 준영속 상태로 코드에서 영속상태, 준영속 상태로 설정하여 초기화를 해보고 프록시를 확인해보자. 프록시 상태는 아래의 방법들로 확인이 가능하다.

- 프록시 인스턴스의 초기화 여부 확인
  PersistenceUnitUtil.isLoaded(Object entity)

```java
System.out.println("isLoaded = "+ emf.getPersistenceUnitUtil().isLoaded(refMember));  // boolean 결과
```

- 프록시 클래스 확인 방법

```java
entity.getClass().getName() 출력(이전 코드들에서 작업한 것과 같다)
```

> 참고

Hibernate의 프록시 강제 초기화

- org.hibernate.Hibernate.initialize(entity);

```
Hibernate.initialize(refMember); // 강제 초기화
```

- JPA 표준은 강제 초기화 없으므로, 강제로 DB에서 호출하도록 이전처럼 (proxy)member.getName() 을 작성하여 확인하자.

# 2. 즉시로딩과 지연로딩

- 맨처음의 문제를 다시 고민해보자. Member를 조회할 때 Team도 함께 조회해야 할까? 말아야할까?
- 이 문제는 즉시로딩과 지연로딩으로 해결 할 수 있다.

### 지연로딩 LAZY

- 전체 APP중에 Member를 조회할때는 Member만 쓰고 Team을 동시에 조회시키지 않고 싶다면 지연로딩을 사용한다.

```java
@Entity
public class Member extends BaseEntity {
     ....

    @ManyToOne(fetch = FetchType.LAZY) // 지연로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

> 코드작업

```JAVA
Team team = new Team();
            team.setName("teamA");
            em.persist(team);

            Member member1 = new Member();
            member1.setUsername("member1");
            member1.setTeam(team);
            em.persist(member1);

            em.flush();
            em.clear();

            Member m = em.find(Member.class, member1.getId()); // 쿼리를 보면 member쿼리만 조회해온다.

            System.out.println("m = " + m.getTeam().getClass()); //Team 추가후에 Team의 프록시가 나오는 모습확인

            System.out.println("==============");
            System.out.println("teamName = "+m.getTeam().getName());      //  Team의 속성을 사용하는 시점에, 프록시가 초기화하여 Team의 쿼리를 가져온다.
            System.out.println("==============");
```

> 결과 콘솔창

```sql
    select
        member0_.MEMBER_ID as member_i1_3_0_,
        member0_.INSERT_MEMBER as insert_m2_3_0_,
        member0_.createdDate as createdd3_3_0_,
        member0_.lastModifiedBy as lastmodi4_3_0_,
        member0_.lastModifiedDate as lastmodi5_3_0_,
        member0_.TEAM_ID as team_id7_3_0_,
        member0_.USERNAME as username6_3_0_
    from
        Member member0_
    where
        member0_.MEMBER_ID=?
m = class hellojpa.Team$HibernateProxy$sx7qMf9G
==============
Hibernate:
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_
    from
        Team team0_
    where
        team0_.TEAM_ID=?
teamName = teamA
==============
```

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_5.png">

- 지연로딩 LAZY을 사용해서 team을 프록시로 만들고 참조변수를 이용하여 조회한다.
- team 사용시점에 프록시를 초기화한다.(= 엔티티생성해서 값 참조해온다.)

### 즉시 로딩

```java
@Entity
public class Member extends BaseEntity {
     ....

    @ManyToOne(fetch = FetchType.EAGER) // 즉시로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

> 콘솔결과창( 이전과 실행코드는 동일하다)

```sql
    select
        member0_.MEMBER_ID as member_i1_3_0_,
        member0_.INSERT_MEMBER as insert_m2_3_0_,
        member0_.createdDate as createdd3_3_0_,
        member0_.lastModifiedBy as lastmodi4_3_0_,
        member0_.lastModifiedDate as lastmodi5_3_0_,
        member0_.TEAM_ID as team_id7_3_0_,
        member0_.USERNAME as username6_3_0_,
        team1_.TEAM_ID as team_id1_7_1_,
        team1_.INSERT_MEMBER as insert_m2_7_1_,
        team1_.createdDate as createdd3_7_1_,
        team1_.lastModifiedBy as lastmodi4_7_1_,
        team1_.lastModifiedDate as lastmodi5_7_1_,
        team1_.name as name6_7_1_
    from
        Member member0_
    left outer join
        Team team1_
            on member0_.TEAM_ID=team1_.TEAM_ID
    where
        member0_.MEMBER_ID=?
m = class hellojpa.Team                                       // 프록시가 아닌 엔티티를 가져온다.
==============
teamName = teamA
==============
```

- Member와 Team을 Join해서 select 해오는 모습을 볼 수 있다.
- 프록시와 초기화가 필요가 없다. 그냥 엔티티객체를 가져온다.
- 만약 수십개의 엔티티들이 서로 연결되어 있다면 Join을 여러번 하게되므로 DB 성능상에 문제가 발생할 것이다.
  <img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_6.png">

### 프록시와 즉시로딩 주의

- 가급적 지연 로딩만 사용(특히 실무에서)
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.

```java
            Team team = new Team();
            team.setName("teamA");
            em.persist(team);

            Team teamB = new Team();
            team.setName("teamB");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("member1");
            member1.setTeam(team);
            em.persist(member1);

            // N+1을 위해 추가
            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setTeam(teamB);
            em.persist(member2);

            em.flush();
            em.clear();

            // JPQL
            List<Member> members = em.createQuery("select m from Member m", Member.class)
                                        .getResultList();
```

> 콘솔결과

```sql
    /* select
        m
    from
        Member m */ select
            member0_.MEMBER_ID as member_i1_3_,
            member0_.INSERT_MEMBER as insert_m2_3_,
            member0_.createdDate as createdd3_3_,
            member0_.lastModifiedBy as lastmodi4_3_,
            member0_.lastModifiedDate as lastmodi5_3_,
            member0_.TEAM_ID as team_id7_3_,
            member0_.USERNAME as username6_3_
        from
            Member member0_
Hibernate:                                            // teamA
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_
    from
        Team team0_
    where
        team0_.TEAM_ID=?
Hibernate:                                               // teamB
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_
    from
        Team team0_
    where
        team0_.TEAM_ID=?
```

> N+1 문제

현재 member1 : TeamA , member2 : TeamB 상황이다. JPQL은 쿼리를 해석한대로 Member객체들을 가져온다.

그런데 Team과 Member는 즉시로딩인 상태이다. 그러므로 member1, member2에 해당하는 Team들을 쿼리로 가져온다.

```
select * from MEMBER;
----------------------
select * from TEAM where teamid = teamA
----------------------
select * from TEAM where teamid = teamB
```

이렇게 1개의 Member조회 쿼리에, teamA,teamB를 찾아서 조회해오는 N개의 쿼리가 추가되는 문제를 N+1 문제라고한다.

이 문제는 DB성능을 떨어트릴 위험이 매우 높다.

> 애노테이션 속 즉시/지연 로딩

- @ManyToOne, @OneToOne은 defalut가 즉시 로딩이다. -> LAZY로 설정해주자.
- @OneToMany, @ManyToMany는 default가 지연 로딩이다.

### 지연 로딩 활용

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_7.png">

- Member와 Team은 자주 함께 사용 -> 즉시 로딩
- Member와 Order는 가끔 사용 -> 지연 로딩
- Order와 Product는 자주 함께 사용 -> 즉시 로딩

### 실무

- 모든 연관관계에 지연 로딩을 사용해라!
- 실무에서 즉시 로딩을 사용하지 마라!
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!(뒤에서 설명)

```
List<Member> members = em.createQuery("select m from Member m join fetch m.team", Member.class)
                                       .getResultList();
===========================================================================================================================
위처럼 수정하면 fetchjoin을 사용할 수 있다.
 - N+1문제는 Lazy(지연로딩)으로 설정하고 fetchjoin을 설정하면 해결할 수 있다.
 실무에서는 위작업은 한번에 Member 에 필요한 team의 값들이 다들어간 쿼리를 만들어 조회할수 있다.
===========================================================================================================================
    /* select
        m
    from
        Member m
    join
        fetch m.team */ select
            member0_.MEMBER_ID as member_i1_3_0_,
            team1_.TEAM_ID as team_id1_7_1_,
            member0_.INSERT_MEMBER as insert_m2_3_0_,
            member0_.createdDate as createdd3_3_0_,
            member0_.lastModifiedBy as lastmodi4_3_0_,
            member0_.lastModifiedDate as lastmodi5_3_0_,
            member0_.TEAM_ID as team_id7_3_0_,
            member0_.USERNAME as username6_3_0_,
            team1_.INSERT_MEMBER as insert_m2_7_1_,
            team1_.createdDate as createdd3_7_1_,
            team1_.lastModifiedBy as lastmodi4_7_1_,
            team1_.lastModifiedDate as lastmodi5_7_1_,
            team1_.name as name6_7_1_
        from
            Member member0_
        inner join
            Team team1_
                on member0_.TEAM_ID=team1_.TEAM_ID
```

- 즉시 로딩은 상상하지 못한 쿼리가 나가는 위험이 매우 높다.

# 3. 영속성 전이(CASCADE)와 고아 객체

## 영속성 전이(CASCADE)

```java
@Entity
public class Parent {
    @Id
    @GeneratedValue
    private Long id;

    private String name;

    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)      // 추가
    private List<Child> childList = new ArrayList<>();

    public void addChild(Child child){                                  //양방향 매핑의 편의메서드
        childList.add(child);
        child.setParent(this);
    }
```

- Child 와 Parent는 양방향 다대일 관계이다. mappedBY에 cascade만 추가했다.
  > jpaMain.java

```
 Child child1 = new Child();
            Child child2 = new Child();

            Parent parent = new Parent();
            parent.addChild(child1);         // Parent생성 child를 넣어준다.
            parent.addChild(child2);


            em.persist(parent);              //parent를 persist하는데, 아래있는 parent객체 아래 List들을 전부 persist 해버린다.
//            em.persist(child1);
//            em.persist(child2);
```

> 콘솔 결과

```
    /* insert hellojpa.Child
        */ insert
        into
            Child
            (name, parent_id, id)
        values
            (?, ?, ?)
```

- em.persist(parent); 하여 parent만 영속화했는데, child도 들어가고 있다.
  <img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/8_8.png">

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들도 싶을 때 사용한다.
- 예: 부모 엔티티를 영속성 컨테이너에 저장할 때 자식 엔티티도 함께 저장.
- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.
- Parent를 생성할때 Child도 생성하여 lifecycle을 맞추려는 의도로 사용한다.(저장되면 저장, 삭제되면 삭제)

### CASCADE의 종류

- **ALL**: 모두 적용
- **PERSIST**: 영속만
- **REMOVE**: 삭제만
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

## 고아 객체

```java
@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST, orphanRemoval = true)
private List<Child> childList = new ArrayList<>();
```

> JPAMain.java

```java
            (...위 코드)
            em.flush();
            em.clear();

            Parent findParent = em.find(Parent.class, parent.getId());
            findParent.getChildList().remove(0);
            // 자식 엔티티를 컬렉션에서 제거.   H2에서 확인하면 Child row하나가 사라져있다.
```

> 콘솔 결과

```
Hibernate:
    /* delete hellojpa.Child */ delete
        from
            Child
        where
            id=?
```

- 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다.

### 고아 객체 - 주의

- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.
- 참조하는 곳이 하나일 때 사용해야함. 즉 특정 엔티티가 개인을 소유할 때 사용

```
- Child가 Parent엔티티에서만 참조하고 있는 단일 소유자 관계
- 게시판의 첨부파일들을 단일 소유자 엔티티에 걸어두고 사용 할때가 있다.
```

- @OneToOne, @OneToMany만 가능
- 참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다.

```
Parent findParent = em.find(Parent.class, parent.getId());
em.remove(findParent);
=================================================
 - parent와 함께 List에 존재하는 모든 자식(child)이 제거된다.
 - 이것은 CascadeType.REMOVE처럼 동작한다.
```

### 영속성 전이 + 고아객체, 생명주기

- CascadeType.ALL + orphanRemovel=true 상태일때를 보자.
- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거할수 있다.
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음

```
em.persist(parent) , em.remove(parent)
findParent.getChildList().remove(0);
==========================================
parent가 child의 생명주기를 모두다 관리할 수 있다.
```

- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용하다.

# 실습

> 모든 연관관계를 지연 로딩으로

```
@ManyToOne,  @OneToOne

이면 One 정보는 하나(작아보)이니까 정보를 묶어서 한번에 보여주는게 좋아보이므로, 즉시로딩으로 설계한것 같다.
그러나 실무적으로 이렇게 간단할 수 없었을 것이다.

default값인 즉시로딩(EAGER)을 LAZY로 수정해주자.

```

> 영속성 전이 설정

```
Order 생성시점에 Delivery도 같이 생성하여 lifecycle을 맞추겠다는 의미이다.

JPAMAIN에서 Order를 하나 생성할때 Delivery하나 넣고,  orderItem을 넣는다.(set 또는 add 메서드로)

이후 Order만 persist한번해주면 전부다 영속화 될 것이다.

비즈니스에 따라 설정하거나 제외해주면 된다.
```
