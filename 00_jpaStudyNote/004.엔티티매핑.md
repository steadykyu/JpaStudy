## 요약해보기
### 1. 객체와 테이블 매핑
@Entitiy, @Table 애노테이션을 통해 매핑이 가능하다.

### 2. 데이터 베이스 스키마 자동 생성
App 실행 시점에 DDL(Data Definition Language) 쿼리가 자동 생성된다. 이러한 DDP은 persistence.xml에서 속성값들을 변경이 가능하다.

### 3. 필드와 컬럼 매핑
> 아래 애노테이션으로 필드와 컬럼 매핑이 가능하다.
```
@Column
@Temporal  -> LocalDate 필드시 필요없음.
@Enumerated
@Lob
@Transient
```
애노테이션마다 세부 속성들이 존재한다.(생략-api 참조하거나 아래 글을 보자.)

### 4. 기본 키 매핑

> @id
```java
 @Id
 private Long id;
```
기본키(pk)를 지정해준다.

@GeneratedValue를 적지않으면 직접 할당

> @GeneratedValue 를 활용한 자동 할당
```java
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
```
이는 해당 컬럼에 값을 자동으로 할당해준다.(1,2,3...)

H2의 default는 AUTO이며 이외의 IDENTITY, sequence, TABLE 전략을 가지고 있다.

기본키(식별자) 전략으로는 long형 + 대체키 + 키 생성전략을 적절히 사용하는 것을 권장한다.
-------
1. 매핑 과정에 있어서, 객체, 필드, 키들이 어떻게 테이블, 컬럼, pk값과 매핑되는지 알아보고, 매핑하는 다양한 속성들을 이해해보자.

# 엔티티매핑
## 1. 객체와 테이블 매핑
### @Entitiy
+ @Entity가 붙은 클래스는 JPA가 관리하며, 이 객체는 엔티티라고 부른다. 
```
주의 
 - 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) - 추후 나올 기술들을 위해서
 - final 클래스, enum, interface, inner 클래스 사용X 
 - 저장할 필드에 final 사용 X
 ```
 + name속성: @Entitiy(name="")
 + JPA에서 사용할 **엔티티이름을** 지정한다.
 + 기본 값으로 클래스 이름을 그대로 사용한다.(가급적 기본값을 사용하자.)

### @Table
+ @Table은 해당 엔티티와 **매핑할 테이블** 을 지정해준다.
```
아래 4가지 기준으로 매핑한 테이블을 구분짓고 가져올수 있다.
1. name 
2. category
3. schema
4. uniqueConstraints
```
### 사용코드
```java
@Entity
//@Table(name = "USER")
public class Member {.....}
```
## 2. 데이터 베이스 스키마 자동 생성

> DDL : Data Definition Language

```
CREATE

ALTER

DROP

RENAME

TRUNCATE
```
> 매핑시 DDL과 관련된 특징
```
 - DDL을 애플리케이션 실행 시점에 자동 생성
 - 테이블 중심 -> 객체 중심
 - 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
 - 이렇게 생성된 DDL은 개발 장비에서만 사용
 - 생성된 DDL은 운영서버에서는 거의 사용하지 않음. 적절히 다듬은 후 사용
```
### 속성들
persistence.xml 에서 DDL 속성값들을 변경 할 수 있다.
```
<property name="hibernate.hbm2ddl.auto" value="create" />
```
+ 아래 value 값에 따라 달라진다.
```
1.create : 기존테이블 삭제 후 엔티티에 맞춰 다시 생성 (DROP + CREATE)

2.create-drop: create와 같으나 종료시점에 테이블 DROP

3.update : 기존 DB는 유지한채, 값이 수정되거나 추가된 변경분만 반영
    - 값이 제거되는 변경은 일어나지 않는다.(데이터 손실 리스크 방지)
    - 운영DB에는 사용하면 안됨

4.validate 엔티티와 테이블이 정상 매핑되었는지만 확인

5.none : 아무 옵션도 사용하지 않음
```
### 실습
> H2의 create속성 소스 코드 결과값

```sql
Hibernate: 
    
    drop table Member if exists
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )
```
> 방언을 Oracle로 수정한다면?

```sql
Hibernate: 
    
    drop table Member cascade constraints
Hibernate: 
    
    create table Member (
       id number(19,0) not null,
        name varchar2(255 char),
        primary key (id)
    )
```
+ Table 기본 char column이 varchar2로 수정된 것을 볼 수 있다. 즉 Oracle 방언에 맞게 쿼리가 날라가는 모습인 것이다.

> Update option Member 엔티티에 age 필드 생성
```sql
Hibernate: 
    
    alter table Member 
       add column age integer not null
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.age as age2_0_0_,
        member0_.name as name3_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
```
+ 테이블을 새로 생성하지 않고 alter 쿼리가 추가됨.

### 주의 
+ 운영 장비에는 **절대 create, create-drop, update 사용하면 안된다.**
```
• 개발 초기 단계는 create 또는 update 

• 테스트 서버는 update 또는 validate 
    - 만약 create하면 서버가 날라가는 문제가 발생한다.

• 스테이징과 운영 서버는 validate 또는 none
    - 몇천만건의 데이터에서 데이터를 수정하거나 없얘면 시스템이 멈출 위험이 크다.
```
+ 운영서버는 왠만하면 꼼꼼하게 직접 개발하거나 쿼리를 수정해서 넣거나 dba에게 주는식으로 해야한다.

### DDL 생성 기능
+ DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다. (런타임에러 발생 X)

+ 다만 DB에만 영향을 주는 것이다.

> Column에 제약조건 걸어주기
```
• 제약조건 추가: 회원 이름은 필수, 10자 초과X , unique 값이야
• @Column(nullable = false, length = 10, unique = true)
```

## 3. 필드와 컬럼 매핑
> 요구 사항을 추가해보자.

1. 회원은 일반 회원과 관리자로 구분해야 한다. 
2. 회원 가입일과 수정일이 있어야 한다. 
3. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.

### 매핑 어노테이션 정리
> 필드값 추가
```java
public class Member {
    @Id
    private Long id;
    @Column(name = "name")
    private String username;
    private Integer age;
    @Enumerated(EnumType.STRING)
    private RoleType roleType;
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
    private LocalDate testLocalDate;
    private LocalDateTime testLocalDateTime;
    @Lob
    private String description;

    public Member(){

    }

}
```
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_1.png" width="50%" height="50%">

+ @Lob : varchar보다 더 큰 범위의 String
### @Column
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_2.png" width="50%" height="50%">

> insertable, updatable 옵션이해하기
```
@Column(name = "name", insertable = false, updatable = false)
    private String username;
```
+ 위 코드로 작성하면, Java App안에서는 등록도 수정도 할수 없다.(강제로 DB에서만 가능)

> @UniqueConstraint
```java
@Entity
@Table(uniqueConstraints={@UniqueConstraint(columnNames={"username"})})
public class Member {...}
```
+ unique는 이름 반영이 이상한 값으로 되기때문에 여기서 쓰지 않는다
+ @Table에서 필드값에 unique 조건을 줄 수 있다.

### @Enumerated
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_3.png" width="50%" height="50%">

+ original시 integer로 들어간다. Enum 값에 맞추어 0, 1, 2, 3 순서로 고정적으로 들어간다.
+ ex) USER, ADMIN -> 0 , 1
+ 여기서 갑자기 값이 추가되면, 순서값으로 들어가기 때문에 문제가 발생할 수 있다.
+ ex) MIDDLE,USER, ADMIN -> 0 , 1, 2   : 이미 DB에는 USER, ADMIN이 0,1로 들어가있는데 0,1,2 순서에 맞게 값을 넣어 문제 발생.
+ 디폴트가 ORDINAL 이므로, 꼭 STRING으로 바꿔주자.

### @Temporal
+ 자바 8이전에는 필요했다. 
+ 그러나 LocalDate(연월데이터), LocalDateTime(연월데이터시간) 데이터 형식으로 매핑이 되므로, 이전 version의 자바에서 만들어진 웹에서만 쓰자.

### @Lob
+ 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
+ @Lob에는 지정할 수 있는 속성이 없다.

### @Transient
필드 매핑X 
+ 데이터베이스에 저장X, 조회X 
+ 주로 메모리상에서만 **임시로** 어떤 값을 보관하고 싶을 때 사용
```
@Transient
private Integer temp;
```

## 4. 기본 키 매핑

### 기본 키 매핑 방법
+ 직접 할당: @Id만 사용
+ 자동 생성(@GeneratedValue) 
```
• TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator 필요
• 계속 정책이 바뀌고 있어서, 그떄그때 확인해보는 것이 좋다.
```
### 직접할당
```
 @Id
 private Long id;
...
```
+ 엔티티에서 id 값을 직접 넣어주어야 한다.
```
Member member = new Member();
member.setId(1L);
```

### 자동생성
``` java
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
```
+ 방언에 따라 자동 지정되며, H2는 AUTO가 기본값이다.

#### IDENTITY 전략
```java
 @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
```
> 출력결과
```sql
Hibernate: 
    
    drop table Member if exists
Hibernate: 
    
    create table Member (
       id bigint generated by default as identity,
        name varchar(255) not null,
        primary key (id)
    )
```
> 특징

+ 기본 키 생성을 데이터베이스에 위임(id값을 1,2,3 순차적으로 넣어줌)
+ 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(예: MySQL의 AUTO_ INCREMENT) 
+ JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행하지만, AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음.
+ 즉 엔티티와 영속성 컨테이너 를 작동시키기 위해서, 억지로 JPA가 em.persist() 시점에 DB쪽으로 insert 쿼리를 자동으로 날린다.
+ 영속성 컨테이너의 commit()에서의 버퍼링기능을 사용하지 못하게 된다. 근데 버퍼링으로 인한 성능차이가 크게 유의하지 않아서 괜찮다.


#### sequence 전략
+ SEQUENCE: 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 오브젝트 사용(ex: ORACLE 주로사용 )
+ sequence 객체에서 값을 가져오며, 이때 sequence는 문자면 안된다.(Long 쓰는것이 좋음)
```java
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ", // 매핑할 데이터베이스 속 시퀀스 이름
        initialValue = 1, allocationSize = 50)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR") //@SequenceGenerator name 속성값과 일치
    private Long id;
```
> 결과값
```sql
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 50
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255) not null,
        primary key (id)
    )
Hibernate: 
    call next value for MEMBER_SEQ
```
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_4.png" width="50%" height="50%">

+ 만약 Table마다 sequence를 따로 관리하고 싶다면 @SequenceGenerator의 sequenceName으로 여러 sequence생성하고 관리가 가능하다.
```
a 시퀀스 : 1 2 3 4
b 시퀀스 : 1 3 5 7 ...
Table은 id로 필요로 하는 시퀀스와 연결하면 되는것
```
+ jpa가 sequence전략이면 DB속 시퀀스(MEMBER_SEQ) 에서 요청한 값(1,2,3)만을 가져온 후, 영속성 컨텍스트에 넣어준다.(call next value for MEMBER_SEQ)

+ 이때 쿼리는 쿼리 저장소에 그대로 있으므로 버퍼링이 가능해진다.

+ 그럼 이런 의구심이 들어야한다. 계속 DB 네트워크를 왔다갔다 해서 성능이 느려지지 않을까? allocationsize으로 최적화해보자.

> initialValue allocationsize 성능최적화 기능
+ Defalut allocationSize = 50이다.

+ 즉 한번 call할때 DB에 미리 sequence값을 50개 올려놓고 가져온다. 

> 연속으로 3개의 값을 영속성 컨테이너가 넣는다고 가정하자.
```java
Member member1 = new Member();
        Member member2 = new Member();
        Member member3 = new Member();
        member1.setUsername("A");
        member2.setUsername("B");
        member3.setUsername("C");
        em.persist(member1);
        em.persist(member2);
        em.persist(member3);
```
> DB안의 값
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_5.png" width="50%" height="50%">

+ MEMBER_SEQ가 51값이다.(1은 초기에 하나 넘겨주고, 이를 포함하여 디폴트 값인 50개를 생성해서 51이 되있는 것이다.)

> 콘솔 결과창
```SQL
Hibernate: 
    call next value for MEMBER_SEQ    // 처음에는 1의 값이 영속성 컨테이너로 들어온다
Hibernate: 
    call next value for MEMBER_SEQ    // 이때 2,3의 값을 영속성 컨테이너로 들어온다.(정확히는 50까지)
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```
+ 처음에는 첫번째 값에 1을 넣기 위해 -49가 시퀀스에 들어간다. (allocationSize(50) - 49 = 1(DB값))

+ 첫번째 call next value for MEMBER_SEQ 후 DB에서 1의 값이 영속성 컨테이너에 들어온다.

+ 두번째 call next value for MEMBER_SEQ 후 메모리를 통해 2,3의 값이 영속성 컨테이너에 들어온다.

+ 이미 50까지 call 했기때문에, call 한번에 50개 까지 컨텍스트쪽 메모리에 저장되어 있는 것이다.

+ 동시에 여러 서버에서 호출해도 서버 1 : 1\~50 개, 서버 2 : 51\~100개 서로 나누어 작동되므로 동시성 문제가 일어나지 않는다.

#### TABLE 전략
+ 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
+ 장점: 모든 데이터베이스에 적용 가능
+ 단점: 성능
```JAVA
@TableGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        table = "MY_SEQUENCES",
        pkColumnValue = "MEMBER_SEQ", allocationSize = 1)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
```
> 결과창 
```sql
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255) not null,
        primary key (id)
    )
Hibernate: 
    
    create table MY_SEQUENCES (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    insert into MY_SEQUENCES(sequence_name, next_val) values ('MEMBER_SEQ',0)
```
+ MY_SEQUENCES 테이블을 생성한다.
> 속성
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_6.png" width="50%" height="50%">

+ TABLE을 만들뿐 작동방식은 SEQUENCE와 같다.
+ 그런데 잘 안사용한다.

#### 권장하는 식별자 전략
+ 기본 키 제약 조건: null 아님, 유일, 변하면 안된다.
+ 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자. (임의로 내가 키를 만드는 것)
+ 예를 들어 주민등록번호도 기본 키로 적절하기 않다. (정치 사회적 문제로 인한 사용불가이슈)
+ 권장: Long형 + 대체키 + 키 생성전략 사용

## 5. 실전 예제1 -요구사항 분석과 기본 매핑
+ 이전 환경 설정 : jpashop 프로젝트를 새로만든후, 기존의 ex1-hello-jpa와 같은 환경으로 맞춰주자.(pom.xml, persistence.xml)
    + 1장 참고
+ h2도 jpashop.db로 새롭게 연결해준다.
    + h2 파일 내 메모장 참고

> 요구사항에 맞추어 아래처럼 도메인을 작성해보자.
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_7.png" width="50%" height="50%">

> 앞으로 우리가 만들 기능. 알고만 있고 넘어가자. 
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_8.png" width="50%" height="50%">

> DB테이블 설계와 엔티티설계
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_9.png" width="50%" height="50%">
<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_10.png" width="50%" height="50%">

+ 그림에 맞게 코드를 작성하자.(아래는 ORDER 엔티티이다.)
``` java 
@Entity
@Table(name ="ORDERS")
public class Order {

    @Id @GeneratedValue
    @Column(name = "ORDER_ID")
    private Long id;      // pk(기본키)

    @Column(name = "MEMBER_ID")
    private Long memberId; // fk(외래키)

    private Member member; // 객체지향적이기 위해 Member추가.

    public Member getMember() {
        return member;
    }

    public void setMember(Member member) {
        this.member = member;
    }

    private LocalDateTime orderDate;    // DBA 분들이 원하는 테이블명 : ORDER_DATE, order_date

    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    .....Getter Setter......
```
+ 원래는 Setter보다는 생성자로 값을 넣는것이 유지보수에 더 좋다.(Setter는 수정가능성 높음)
+ 보기 편하게 일단 Setter로 진행
+ LocalDateTime은 따로 설정하지 않아도, JPA가 알아서 매핑해준다.
+ Enumtype은 Enum 클래스 생성후 @Enumerated(EnumType.**STRING**)로 매핑을 해주자.
+ sql 예약어인 ORDER_BY에 겹치치 않게 하기위해 테이블 명을 ORDERS로 설정한다.
+ 엔티티설계의 필드와 테이블 설계의 컬럼 이름이 다를경우,  @Column(name = "ORDER_ID")로 매핑해준다.
```
엔티티 : id
DB : order_id 이므로 @Column을 사용해서 매핑시켜준다.
```
> 테이블 설계 관례
```
- 관례가 다 다르지만, 강사님은 데이터를 엔티티 클래스에 그대로 사용하는 것을 선호한다.
    + 메타데이터 : 데이터에 대한 데이터(정보)
- DB에서 데이터를 수정하지않은채 사용하고 , 엔티티에서 제약을 걸고 알려주는 것을 선호한다. ex) @Column(length = 10) : 길이가 10인 컬럼
- 인덱스도 가급적이면, 엔티티에서 걸어놔야 DBA 분들이 쿼리짤때 참고할 수 있다. 엔티티의 @Table 애노테이션으로 걸수 있다.(unique 제약도 마찬가지)
- Orderdate 필드는 JPA에서는 Camel 형식으로 orderDate 저장하지만, 스프링 부트로 사용시 order_date로 수정해준다.
- DBA와의 협업때문에 이런 관례들이 만들어졌다. 
- 참고  fk(외래키) : 두개의 테이블을 연결해주는 key 값
        pk(기본키) : 데이터의 중복을 방지하기위해 존재하는 고유키(ex) 실세계의 주민등록번호
```
> 엔티티들을 다 만든후에 실행코드를 살펴보자.
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();

        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Order order = em.find(Order.class, 1L);
            Long memberId = order.getMemberId();
            Member member = em.find(Member.class,memberId);  
            //case1---------------------------------------------------------
            
//            Member findmember = order.getMember();
//            findmember.memberId 
            //case2----------------------------------------------------------

            tx.commit();
        } catch (Exception e){
            tx.rollback();
        } finally{
            em.close();
        }

        emf.close();
    }
}
```
+ case1
```
- Order에서 찾은 Member의 식별자 값(memberID)을 그대로 사용하는 경우 - 더이상 참조를 할 수 없음
- 객체 지향적이지 않은 관계형 DB에 맞춘 설계.
```
+ case2
```
- Order 에 Member 필드가 있다면 어떨까? 
- Member객체가 필드로 있으면 참조변수에 객체를 넣어, 객체안의 값들을 참조하는 객체지향적 설계가 완성된다.

```
#### 데이터 중심 설계의 문제점(case1경우)
+ 객체 엔티티를 테이블 설계에 맞춘 방식이다.
+ 테이블의 외래키(식별자)를 객체에 그대로 가져옴
```
식별자란 하나의 엔티티(테이블) 내에서 각각의 인스턴스(로우)를 유일(Unique)하게 구분해 낼 수 있는 속성(컬럼) 또는 속성 그룹
```
+ 참조가 불가능하므로 객체 그래프 탐색이 불가능
+ 참조가 없으므로 객체 그래프의 UML도 잘못된 그림인 것이다.

> UML(unified Modeling Language)

<img src ="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/4_11.png" width="50%" height="50%">
