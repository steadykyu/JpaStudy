## 1.상속관계 매핑

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_1.png">

+ 왼쪽의 RDBMS 논리모델 오른쪽의 객체모델
+ 관계형 데이터베이스는 상속 관계X 
+ 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
+ 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
+ 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
   1. 각각 테이블로 변환 -> 조인 전략
   2. 통합 테이블로 변환 -> 단일 테이블 전략
   3. 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

### 주요 어노테이션
+ @Inheritance(strategy=InheritanceType.XXX) 
    1. JOINED: 조인 전략
    2. SINGLE_TABLE: 단일 테이블 전략
    3. TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
+ @DiscriminatorColumn(name=“DTYPE”) 
+ @DiscriminatorValue(“XXX”)

### 조인 전략
+ 코드작업
> Item
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)       // Join 전략
@DiscriminatorColumn              
public abstract class Item {

    @Id
    @GeneratedValue
    private Long id;

    private String name;
    private int price;
    (getter setter)
```
+ @DiscriminatorColumn 그림속 테이블의 Dtype column을 추가해주며, name = "" 으로 이름설정 가능
+ 입력하지않으면 생략된다.(운영상 이유로 Dtype column 보여주는게 좋다.)

> Movie
```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
    private String director;
    private String actor;
    (getter setter)
```
+ @DiscriminatorValue("M") : default로는 TABLE 명이 들어간다. 테이블에 들어가는 값 수정을 위해 사용한다.
> 실행파일(JPAMain) 
```java

            Movie movie = new Movie();
            movie.setDirector("규하");
            movie.setActor("박보영");

            //이름과 price는 Item에 getter setter가 있어야 메서드 호출이 가능능
           movie.setName("바람과 함께 사라지다.");
           movie.setPrice(10000);

            em.persist(movie);
            
            // 쿼리 확인을  사용한다.
            em.flush();        
            em.clear();

            Movie findMovie = em.find(Movie.class, movie.getId());
            System.out.println("findMovie = " + findMovie);
            // movie table이 item table과 inner join해서 값을 찾아내는 모습을 확인할수 있다.

            tx.commit();
```
> H2 Table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_3.png">

> 저장시 쿼리
```
 create table Item (
       DTYPE varchar(31) not null,
        id bigint not null,
        name varchar(255),
        price integer not null,
        primary key (id)
    )
create table Movie (
       actor varchar(255),
        director varchar(255),
        id bigint not null,
        primary key (id)
    )
    (....)
```
> 조회시 쿼리
```
Hibernate: 
    select
        movie0_.id as id2_2_0_,
        movie0_1_.name as name3_2_0_,
        movie0_1_.price as price4_2_0_,
        movie0_.actor as actor1_6_0_,
        movie0_.director as director2_6_0_ 
    from
        Movie movie0_ 
    inner join
        Item movie0_1_ 
            on movie0_.id=movie0_1_.id 
    where
        movie0_.id=?
findMovie = hellojpa.advanced_mapping.Movie@43bf5397
```
+ inner join으로 가져오는 모습

#### 조인 정략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_2.png">

+ 장점
    - 테이블 정규화
    - 외래 키 참조 무결성 제약조건 활용가능
```
무결성 제약조건: 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건
주문테이블이 있을때, Item조회시 Item객체만 보면 된다. 다른 추가적인 테이블이나 열들이 나오지 않음.
```
    - 저장공간 효율화

+ 단점
    - 조회시 조인을 많이 사용, 성능 저하
    - 조회 쿼리가 복잡함
    - 데이터 저장시 INSERT SQL 2번 호출
+ 단점이 요즘에는 크게 안느껴진다.
+ 오히려 객체와 가장 유사한점, 설계에서의 장점등 때문에 조인전략을 정석으로 보는게 좋다.

### 단일 테이블 전략
+ @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 만 추가해주면 된다.
+ @DiscriminatorColumn은 자동으로 생성후 돌아간다. 그래야만 테이블 구별이 가능하기 때문이다.
> 저장시 쿼리
```
    create table Item (
       DTYPE varchar(31) not null,
        id bigint not null,
        name varchar(255),
        price integer not null,
        actor varchar(255),
        director varchar(255),
        artist varchar(255),
        author varchar(255),
        isbn varchar(255),
        primary key (id)
    )
```
+ 단일 테이블을 생성하는 모습
> 조회시 쿼리
```
    select
        movie0_.id as id2_0_0_,
        movie0_.name as name3_0_0_,
        movie0_.price as price4_0_0_,
        movie0_.actor as actor5_0_0_,
        movie0_.director as director6_0_0_ 
    from
        Item movie0_ 
    where
        movie0_.id=? 
        and movie0_.DTYPE='M'
findMovie = hellojpa.advanced_mapping.Movie@77ab22be
```
+ Item 에서만 찾음
> H2 table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_4.png">

#### 단일 테이블 전략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_5.png">

+ 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
+ 단점
    - 거대한 테이블을 제작하므로 자식 엔티티가 매핑한 컬럼은 모두 null 허용(무결성입장에서 애매함)
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

+ 최근 테이블이 커져서 느려지는 임계점이 생각보다 잘 오지는 않음.

### 구현클래스마다 테이블 전략
> 코드작업
+ @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) 만 Item에서 수정한다.
+ public abstract class Item {...}
```
 - 추상 클래스로 생성시 item Table 생성없이 속성값이 들어간다.
 - Item 테이블이 꼭 필요할때만 Item을 추상클래스로 안만들면된다.
```
> 저장시 쿼리
```
    create table Movie (
       id bigint not null,
        name varchar(255),
        price integer not null,
        actor varchar(255),
        director varchar(255),
        primary key (id)
    )
    ... Album, Book table 생성
```
> 조회시 쿼리
```
    select
        movie0_.id as id2_0_0_,
        movie0_.name as name3_0_0_,
        movie0_.price as price4_0_0_,
        movie0_.actor as actor5_0_0_,
        movie0_.director as director6_0_0_ 
    from
        Item movie0_ 
    where
        movie0_.id=? 
        and movie0_.DTYPE='M'
findMovie = hellojpa.advanced_mapping.Movie@77ab22be
```
+ 모든 column이 다있는 Item 쿼리에서 가져옴.

+ Item의 name과 price 속성값이 들어가 있는 모습을 볼 수 있다.

> H2 Table
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_6.png">

#### 구현 클래스마다 테이블 전략 정리
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/7_7.png">

+ 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X 
+ 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능(테이블 null이 없게 만들 수 있음)
+ 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) 
    - 자식 테이블을 통합해서 쿼리하기 어려움
    - 새로운 테이블 추가시 복잡해짐.

> 조회시 쿼리
```
Movie, Album, Book 3개의 테이블을 union한 테이블을 생성후 조회함.
```

### 참고
+ 재미있는 장점으로 그저 어노테이션만 바꿨는데 전략 변경이 가능한 모습을 볼 수 있다.
+ 조인 전략의 장단점, 단일 테이블의 장단점을 DBA와 비교하면서 작업하면 된다.
+ 강사님은 매우 단순한 타입이고, 확장할 일이 없을때 단일테이블로 제작하고 비즈니스적으로 중요하면 조인전략을 사용하시는 편이다.
