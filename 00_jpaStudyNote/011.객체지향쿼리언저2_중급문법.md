# 1. 경로 표현식
## 경로 표현식
+ '.'(점)을 찍어 객체 그래프를 탐색하는 것
+ 그림1

## 경로 표현식 용어정리
+ 상태 필드(state field): 단순히 값을 저장하기 위한 필드
 -(ex: m.username) 
+ 연관 필드(association field): 연관관계를 위한 필드
  - 단일 값 연관 필드:
    - @ManyToOne, @OneToOne, 대상이 **엔티티**(ex: m.team) 
  - 컬렉션 값 연관 필드:
    - @OneToMany, @ManyToMany, 대상이 **컬렉션**(ex: m.orders)

## 경로 표현식 특징
+ 상태 필드(state field): 경로 탐색의 끝, 추가탐색X
+ 단일 값 연관 경로: **묵시적 내부 조인(inner join) 발생**, 추가탐색O 
+ 컬렉션 값 연관 경로: **묵시적 내부 조인 발생**, 추가탐색X 
  - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

> 단일 값 연관 경로 탐색
```java
            Team team = new Team();
            em.persist(team);

            Member member1 = new Member();
            member1.setUsername("관리자1");
            member1.setTeam(team);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("관리자2");
            member2.setTeam(team);
            em.persist(member2);

            em.flush();
            em.clear();

            String query =
                    "select m.team from Member m";
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();
```
> 결과 쿼리
```sql
   /* select
        m.team 
    from
        Member m */ select
            team1_.id as id1_3_,
            team1_.name as name2_3_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.id
```
+ DB입장에서보면 해당 명령을 처리하기위해 묵시적으로 innerjoin이 일어나야한다.
+ 실무적으로 이런 묵시적 innerjoin은 쿼리 튜닝시 많은 어려움을 준다.
+ 추가 탐색이 가능함
```java
String query =
                    "select m.team.id from Member m";       // 엔티티 안의 값을 출력하도록 설정.
            List<Long> result = em.createQuery(query, Long.class)
                    .getResultList();
            for (Long aLong : result) {
                System.out.println("aLong = " + aLong);
            }
// aLong = 1 출력
```

> 컬렉션 값 연관경로
```java
            String query =
                    "select t.members from Team t";
            List<Collection> result = em.createQuery(query,Collection.class)
                    .getResultList();
            System.out.println("result = " + result);
```
```sql
Hibernate: 
    /* select
        t.members 
    from
        Team t */ select
            members1_.id as id1_0_,
            members1_.age as age2_0_,
            members1_.TEAM_ID as team_id5_0_,
            members1_.type as type3_0_,
            members1_.username as username4_0_ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result = [Member{id=2, username='관리자1', age=0}, Member{id=3, username='관리자2', age=0}]
```
+ 위 코드처럼 묵시적 innerjoin이 발생하며, 컬렉션 자체를 뽑는건 가능하다.
+ 그러나 추가탐색이 불가능하다고 쓴것과 같이 **컬렉션 안쪽의 값을 select에 꺼낼수가 없다.**
```java
String query = "select t.members.id from Team t"; // 불가능하다!!
```
+ 컬렉션 안의 값을 보고싶다면 아래처럼 명시적 조인을 해주어야한다.
```java
            // 명시적 조인
            String query =
                    "select m.username from Team t join t.members m";
```
### 명시적 조인, 묵시적 조인
+ 명시적 조인: join 키워드 직접 사용(외부, 내부 조인가능)
  - 예) select m from Member m join m.team t
+ 묵시적 조인: 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능) 
  - 예) select m.team from Member m
### 경로 탐색을 사용한 묵시적 조인시 주의사항
+ 항상 내부 조인
+ 컬렉션은 경로 탐색의 끝, 컬렉션 안쪽 값을 얻기 위해서는 명시적 조인을 통해 별칭을 얻어야함
+ 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 **묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌**

### 실무 조언 및 정리
+ **가급적 묵시적 조인 대신에 명시적 조인 사용**
+ 조인은 SQL 튜닝에 중요 포인트
+ 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려우므로 가급적 사용하지 않는다.(쿼리 튜닝시 어려움을 겪음)

# 2.페치 조인(fetch join)
+ **실무에서 정말정말 중요하다.**
+ SQL 조인 종류X 
+ JPQL에서 **성능 최적화**를 위해 제공하는 기능
+ 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
+ join fetch 명령어 사용
+ 페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

## 2.1엔티티 페치 조인
+ 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에) 
+ SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELECT
+ JPQL 코드
```sql
  select m from Member m join fetch m.team 
```
+ 결과 SQL
```sql
SELECT M.*, T.* FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
+ 그림2

### 2.1.1페치 조인을 안했을때
```java
           Team teamA = new Team();
            teamA.setName("팀A");
            em.persist(teamA);

            Team teamB= new Team();
            teamB.setName("팀B");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("회원1");
            member1.setTeam(teamA);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("회원2");
            member2.setTeam(teamA);
            em.persist(member2);

            Member member3 = new Member();
            member3.setUsername("회원3");
            member3.setTeam(teamB);
            em.persist(member3);

            em.flush();
            em.clear();

            String query =
                    "select m from Member m";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername()+"," + member.getTeam().getName());
            }
```
+ 현재 지연 로딩이므로, Team을 사용할때 Team과 관련된 쿼리를 날려준다.
+ getTeam()에서 Team의 프록시가 나오고, getName()에서 프록시가 영속성 컨텍스트에 name값을 요청한다. 그러면, DB에서 쿼리가 실행된후 값을 보내준다.
```
            회원1, 팀A - SQL 에서 가져옴
            회원2, 팀A - (컨터이너의 1차캐시에서 가져옴)
            회원3, 팀B - SQL에서 가져옴.
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as team_id5_0_,
            member0_.type as type3_0_,
            member0_.username as username4_0_ 
        from
            Member member0_
Hibernate:         //  필요시 에만 날리는 모습
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_ 
    from
        Team team0_ 
    where
        team0_.id=?
member = 회원1,팀A
member = 회원2,팀A
Hibernate:            //  필요시 에만 날리는 모습
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_ 
    from
        Team team0_ 
    where
        team0_.id=?
member = 회원3,팀B
```
+ 만약 게시판에서 회원이 100명인데 각각 팀이 다르다면 어떻게 될까? -> N+1 문제가 발생.
+ 즉 100번쿼리가 날라가고(각각의 Team), 1의 쿼리가 추가된다( 맨처음의 Member객체에 대한 쿼리)

### 2.1.2엔티티 페치 조인 적용
```java
// --------------------fetch join
            String query =
                    "select m from Member m join fetch m.team"; // left, right 등 outer join가능.
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername()+"," + member.getTeam().getName());
            }
```
+ 이때의 getTeam()으로 얻은 Team은 프록시가 아니라, 진짜 객체 Team을 의미한다.
+ 주로 조회업무를 할때 매우 많이 사용한다.
+ 지연로딩으로 설정해도 fetch join의 우선순위가 더 높다.

> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    from
        Member m 
    join
        fetch m.team */ select
            member0_.id as id1_0_0_,
            team1_.id as id1_3_1_,
            member0_.age as age2_0_0_,
            member0_.TEAM_ID as team_id5_0_0_,
            member0_.type as type3_0_0_,
            member0_.username as username4_0_0_,
            team1_.name as name2_3_1_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.id
member = 회원1,팀A
member = 회원2,팀A
member = 회원3,팀B
```
+ 즉시로딩과 같은 모습이 된다. 중요한건 fetch join을 통해 우리가 필요할때마다 즉시로딩의 쿼리를 생성할수 있다는 것이다.

## 2.2 컬렉션 페치 조인
+ 일대다 관계, 컬렉션 페치 조인
+ JPQL 코드
```sql
select t
from Team t join fetch t.members   // Team 안의 List<Member>(members)와 fetch Join
where t.name = ‘팀A' 
```
+ SQL 결과
```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'
```
### 2.2.1 적용코드
```java
          String query =
                    "select t from Team t join fetch t.members"; // left, right 등 outerjoin가능.
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team객체위치 = " +team + "| team객체이름 = "  + team.getName()+ "| members = " + team.getMembers()); 
                for( Member member : team.getMembers()){   // 예) 팀 A 객체안에 있는 List<Member>
                    System.out.println("----> member = "+member);
                }
            }
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        t 
    from
        Team t 
    join
        fetch t.members */ select
            team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as team_id5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as team_id5_0_0__,
            members1_.id as id1_0_0__ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result.size() = 3
team객체위치 = jpql.Team@60dd0587| team객체이름 = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team객체위치 = jpql.Team@60dd0587| team객체이름 = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team객체위치 = jpql.Team@5edacf20| team객체이름 = 팀B| members = [Member{id=5, username='회원3', age=0}]
----> member = Member{id=5, username='회원3', age=0}
```
+ 그림3
+ 그림4

+ 참고: 이전에 양방향매핑이면, 값이 다 들어가지만 읽기만 가능하게 된다는걸 기억하자. 그래서 편의메서드로 값을 안넣어도 값은 들어간다.(기억회상용)
+ **팀A가 두번 나온 이유**
  - Team 입장에서는 일대다 join이기 때문에 데이터가 뻥튀기 될수 있다.
  - 예를 들어 ID = 1, 팀A 인 Team 객체는 영속성 컨텍스트에 위치하고, 회원1 member, 회원2 member와 fetch join을 하는 하므로, 데이터가 뻥튀기된다.(DB 로직과 유사)
  - 그래서 조회한 List\<Team\> 즉 result에서는 팀A가 두번 출력된다. 이때 이 둘은 같은 영속성 컨텍스트에 위치하고 있는 모습을 확인 할수 있다.
+ **팀A객체의 members가 같은 내용인 이유**
  - fetch join은 fK = pk 인 대상에 대하여 한번에 끌어오도록 join 시켜버리기 때문이다.

## 2.3 페치 조인과 distinct
+ SQL의 DISTINCT는 중복된 결과를 제거하는 명령
+ JPQL의 DISTINCT 2가지 기능 제공
  1. SQL에 DISTINCT를 추가
  2. 애플리케이션에서 엔티티 중복 제거

+ 우리의 경우 1번은 데이터가 다르므로 SQL 결과에서 중복 제거에 실패한다.
+ 그림5

### 2.3.1 엔티티 중복 제거
+ DISTINCT가 추가로 애플리케이션에서 중복 제거시도
+ 같은 식별자를 가진 Team 엔티티 제거
+ 그림6

```java
String query =
                    "select distinct t from Team t join fetch t.members"; // left, right 등 outerjoin가능.
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team = " + team + "| teamname = " + team.getName()+ "| members = " + team.getMembers()); // 팀 A
                for( Member member : team.getMembers()){
                    System.out.println("----> member = "+member);
                }
            }
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        distinct t 
    from
        Team t 
    join
        fetch t.members */ select
            distinct team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as team_id5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as team_id5_0_0__,
            members1_.id as id1_0_0__ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result.size() = 2
team = jpql.Team@221a2068| teamname = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team = jpql.Team@7e307087| teamname = 팀B| members = [Member{id=5, username='회원3', age=0}]
----> member = Member{id=5, username='회원3', age=0}
```

## 2.4 페치 조인과 일반 조인의 차이
+ 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음.(지연로딩)
+ JPQL 코드
```
select t
from Team t join t.members m
where t.name = ‘팀A' 
```
+ SQL 결과
```sql
SELECT T.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID 
WHERE T.NAME = '팀A'
```
+ JPQL은 결과를 반환할 때 연관관계 고려X 
+ 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.
+ 위코드는 Team 엔티티만 조회하고, 회원 엔티티는 조회X ,
+ 사용시마다 쿼리를 생성하여 조회한다.(지연로딩, N+1의 문제가능성 있음)
****
## 2.5 페치조인 정리
+ 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩) 
+ 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념
+ JPQL코드
```
select t 
from Team t join fetch t.members
where t.name = ‘팀A' 
```
+ SQL결과
```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID 
WHERE T.NAME = '팀A'
```

# 3. 페치조인의 특징과 한계
## 3.1 특징과한계1
+ 페치 조인 대상에는 별칭을 줄 수 없다. 
  - 하이버네이트는 가능, 가급적 사용X 
```
페치 조인 자체가 연관된 객체, 컬렉션을 전부 끌고오려는 의도로 설계 한 것이다. 그러므로 별칭을 주고 where로 일부만 가져오는 작업들은 하지말도록 JPA 공식문서에서 정하고 있다.
별칭으로 가져올수 있기는 하지만 나중에 운영상 어려움을 초래한다. 굳이 일부를 가져와야한다면 새로운 쿼리를 만들어서 select에서 가져오자.
```
+ 둘 이상의 컬렉션은 페치 조인 할 수 없다. 
  - 이전 컬렉션과는 일대다 관계였다. 여기에 컬렉션이 하나 더 붙으면 일대 다 대 다의 관계가 된다.
  - 이는 데이터 정합성(데이터가 서로 일치함)에 문제를 일으킨다.
+ **컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다. **
  - 위에서 1:N의 경우 데이터가 뻥튀기 되는 모습을 확인할수 있었다.
  - 여기서 1의 입장으로 페이징을 하고 싶지만, 값들은 N만큼 뻥튀기 되어있는 상황이므로 1의 입장으로 페이징을 할수가 없다.
  - 그래서 JPA는 어쩔수없이 DB에서 1:N의 **조인 결과를 모두 메모리에 가져온 다음**, 1을 기준으로 페이징을 메모리에서 다시 수행한다. 
  - 조인의 결과가 100만건 이라면 어플리케이션 메모리 부족으로 OOM이 발생할 수 있다.
> 1:N에서 페이징 적용
```java
String query =
                    "select t from Team t join fetch t.members";
            List<Team> result = em.createQuery(query, Team.class)
                    .setFirstResult(0)
                    .setMaxResults(1)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team = " + team + "| teamname = " + team.getName()+ "| members = " + team.getMembers()); // 팀 A
                for( Member member : team.getMembers()){
                    System.out.println("----> member = "+member);
                }
            }
```
> 쿼리 결과
```sql
Hibernate: 
    /* select
        t 
    from
        Team t 
    join
        fetch t.members */ select
            team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as team_id5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as team_id5_0_0__,
            members1_.id as id1_0_0__ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID -----------------// 보면 페이징 쿼리(limit)가 없이 DB에서 전부다 끌고 오는 모습을 볼 수 있다.
result.size() = 1
team = jpql.Team@60dd0587| teamname = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
```
+ 전부다 끌고 와서 페이징하기 때문에, OOM으로 인한 장애발생 또는 쿼리속도저하가 일어남에도 발견하지 못할 수 있다.
****
+ 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
  - select m from Member m fetch join m.team으로 쿼리를 수정해주면, 다대일 이므로 페이징이 무난하게 가능하다.
+ 하이버네이트는 경고 로그를 남기고, 메모리에서 페이징(매우 위험)
```
WARN: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!
```
### 3.1.1 페이징 해결법
1. 일대다의 쿼리를 다대일의 쿼리로 바꿔준다.
  - select m from Member m fetch join m.team으로 쿼리를 수정해주면, 다대일 이므로 페이징이 무난하게 가능하다.
2. (참고)@BatchSize()를 이용한다.
  - 지연로딩으로 인해 발생하는 N+1의 문제를 fetch join으로 해결하면 페이징을 할수 없는 문제가 발생했다.
  - 이는 fetch join대신 @BatchSize()로 해결하면 N+1 문제해결과 페이징을 적용시킬수 있다.(성능최적화!)
```java
    @BatchSize(size = 100)
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
```
> jpaMain코드
```java
// 2. @Batchsize()를 컬렉션에 추가해준다.
            // 이는 글로벌 세팅으로도 처리가 가능하다.
            // persistence.xml에   <property name="hibernate.default_batch_fetch_size" value="100" />추가
            String query =
                    "select t from Team t";

            List<Team> result = em.createQuery(query, Team.class)       ------------// 여기서 BatchSize인 Team을 100개씩 넘긴다.
                    .setFirstResult(0)
                    .setMaxResults(2)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team = " + team + "| teamname = " + team.getName()+ "| members = " + team.getMembers()); // 팀 A
                for( Member member : team.getMembers()){
                    System.out.println("----> member = "+member);
                }
            }
```
> 쿼리 결과
```sql
Hibernate: 
    /* select
        t 
    from
        Team t */ select
            team0_.id as id1_3_,
            team0_.name as name2_3_ 
        from
            Team team0_ limit ?
result.size() = 2
Hibernate: 
    /* load one-to-many jpql.Team.members */ select
        members0_.TEAM_ID as team_id5_0_1_,
        members0_.id as id1_0_1_,
        members0_.id as id1_0_0_,
        members0_.age as age2_0_0_,
        members0_.TEAM_ID as team_id5_0_0_,
        members0_.type as type3_0_0_,
        members0_.username as username4_0_0_ 
    from
        Member members0_ 
    where
        members0_.TEAM_ID in (
            ?, ?               // TeamA의 아이디, TeamB의 아이디를 한번에 넘긴다.
        )
team = jpql.Team@5e5aafc6| teamname = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team = jpql.Team@542f6803| teamname = 팀B| members = [Member{id=5, username='회원3', age=0}]
----> member = Member{id=5, username='회원3', age=0}
```
+ TeamA, TeamB와 연관된 Member를 전부가져와 준다.
+ 만약 150개의 Team이 있다면, 처음 in query에 100 개의 팀을 넘기고 다음 쿼리에 50개의팀을 넘기는 작동 방식을 가지고 있다.
+ 지연로딩의 N+1의 문제를 처음 객체한번, 통합된 inquery개수 만큼만 날려 성능을 최적화 시킬수 있다.
+ persistence.xml에 아래 글로벌 세팅을 추가하여 사용할 수도 있다.
```
<property name="hibernate.default_batch_fetch_size" value="100" />
```

## 3.2특징과한계2
+ 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
+ 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
  - @OneToMany(fetch = FetchType.LAZY) //글로벌 로딩 전략보다 우선!
+ 실무에서 **글로벌 로딩 전략은 모두 지연 로딩**
+ **최적화가 필요한 곳은 페치 조인 적용**

## 3.3 정리
+ 모든 것을 페치 조인으로 해결할 수 는 없음
+ 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
+ 여러 테이블을 조인해서 **엔티티가 가진 모양이 아닌** 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적이다.
+ 참고 DTO : 계층간 데이터 교환을 위해 사용하는 객체로, DTO는 **로직을 가지지 않는** 순수한 데이터 객체(getter, setter만 존재하는 클래스)이다.
+ 실무 관점 : **fetch join 이란 개념을 알고 있어야** 간단한 fetch join의 코드 작업으로, **운영상 쿼리 성능 이점(최적화)**를 얻을수 있다.(모르면 native query나.. 다른 돌아가는 방식을 택할수 밖에없다.)

# 4. 다형성 쿼리
그림 7

## 4.1 TYPE
+ 조회 대상을 특정 자식으로 한정
+ 예) Item 중에 Book, Movie를 조회해라
+ JPQL 코드
```
select i from Item i
where type(i) IN (Book, Movie) 
```
+ SQL 결과 
```sql
select i from i
where i.DTYPE in (‘B’, ‘M’)   // 아래처럼 변환된다!
```
## 4.2 TREAT
+ 자바의 타입 캐스팅과 유사
+ 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
+ FROM, WHERE, SELECT(하이버네이트 지원) 사용
+ 예) 부모인 Item과 자식 Book이 있다. 
+ JPQL 코드
```
select i from Item i
where treat(i as Book).auther = ‘kim’ 
```
+ SQL결과
> single table 전략시 
```sql
select i.* from Item i
where i.DTYPE = ‘B’ and i.auther = ‘kim’
```
