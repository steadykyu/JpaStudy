# 1. 경로 표현식
## 경로 표현식
+ '.'(점)을 찍어 객체 그래프를 탐색하는 것
+ 그림1

## 경로 표현식 용어정리
+ 상태 필드(state field): 단순히 값을 저장하기 위한 필드
 -(ex: m.username) 
+ 연관 필드(association field): 연관관계를 위한 필드
  - 단일 값 연관 필드:
    - @ManyToOne, @OneToOne, 대상이 **엔티티**(ex: m.team) 
  - 컬렉션 값 연관 필드:
    - @OneToMany, @ManyToMany, 대상이 **컬렉션**(ex: m.orders)

## 경로 표현식 특징
+ 상태 필드(state field): 경로 탐색의 끝, 추가탐색X
+ 단일 값 연관 경로: **묵시적 내부 조인(inner join) 발생**, 추가탐색O 
+ 컬렉션 값 연관 경로: **묵시적 내부 조인 발생**, 추가탐색X 
  - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

> 단일 값 연관 경로 탐색
```java
            Team team = new Team();
            em.persist(team);

            Member member1 = new Member();
            member1.setUsername("관리자1");
            member1.setTeam(team);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("관리자2");
            member2.setTeam(team);
            em.persist(member2);

            em.flush();
            em.clear();

            String query =
                    "select m.team from Member m";
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();
```
> 결과 쿼리
```sql
   /* select
        m.team 
    from
        Member m */ select
            team1_.id as id1_3_,
            team1_.name as name2_3_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.id
```
+ DB입장에서보면 해당 명령을 처리하기위해 묵시적으로 innerjoin이 일어나야한다.
+ 실무적으로 이런 묵시적 innerjoin은 쿼리 튜닝시 많은 어려움을 준다.
+ 추가 탐색이 가능함
```java
String query =
                    "select m.team.id from Member m";       // 엔티티 안의 값을 출력하도록 설정.
            List<Long> result = em.createQuery(query, Long.class)
                    .getResultList();
            for (Long aLong : result) {
                System.out.println("aLong = " + aLong);
            }
// aLong = 1 출력
```

> 컬렉션 값 연관경로
```java
            String query =
                    "select t.members from Team t";
            List<Collection> result = em.createQuery(query,Collection.class)
                    .getResultList();
            System.out.println("result = " + result);
```
```sql
Hibernate: 
    /* select
        t.members 
    from
        Team t */ select
            members1_.id as id1_0_,
            members1_.age as age2_0_,
            members1_.TEAM_ID as team_id5_0_,
            members1_.type as type3_0_,
            members1_.username as username4_0_ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result = [Member{id=2, username='관리자1', age=0}, Member{id=3, username='관리자2', age=0}]
```
+ 위 코드처럼 묵시적 innerjoin이 발생하며, 컬렉션 자체를 뽑는건 가능하다.
+ 그러나 추가탐색이 불가능하다고 쓴것과 같이 **컬렉션 안쪽의 값을 select에 꺼낼수가 없다.**
```java
String query = "select t.members.id from Team t"; // 불가능하다!!
```
+ 컬렉션 안의 값을 보고싶다면 아래처럼 명시적 조인을 해주어야한다.
```java
            // 명시적 조인
            String query =
                    "select m.username from Team t join t.members m";
```
### 명시적 조인, 묵시적 조인
+ 명시적 조인: join 키워드 직접 사용(외부, 내부 조인가능)
  - 예) select m from Member m join m.team t
+ 묵시적 조인: 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능) 
  - 예) select m.team from Member m
### 경로 탐색을 사용한 묵시적 조인시 주의사항
+ 항상 내부 조인
+ 컬렉션은 경로 탐색의 끝, 컬렉션 안쪽 값을 얻기 위해서는 명시적 조인을 통해 별칭을 얻어야함
+ 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 **묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌**

### 실무 조언 및 정리
+ **가급적 묵시적 조인 대신에 명시적 조인 사용**
+ 조인은 SQL 튜닝에 중요 포인트
+ 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려우므로 가급적 사용하지 않는다.(쿼리 튜닝시 어려움을 겪음)

# 2.페치 조인(fetch join)
+ **실무에서 정말정말 중요하다.**
+ SQL 조인 종류X 
+ JPQL에서 **성능 최적화**를 위해 제공하는 기능
+ 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
+ join fetch 명령어 사용
+ 페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

## 2.1엔티티 페치 조인
+ 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에) 
+ SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELECT
+ JPQL 코드
```sql
  select m from Member m join fetch m.team 
```
+ 결과 SQL
```sql
SELECT M.*, T.* FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
+ 그림2

### 2.1.1페치 조인을 안했을때
```java
           Team teamA = new Team();
            teamA.setName("팀A");
            em.persist(teamA);

            Team teamB= new Team();
            teamB.setName("팀B");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("회원1");
            member1.setTeam(teamA);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("회원2");
            member2.setTeam(teamA);
            em.persist(member2);

            Member member3 = new Member();
            member3.setUsername("회원3");
            member3.setTeam(teamB);
            em.persist(member3);

            em.flush();
            em.clear();

            String query =
                    "select m from Member m";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername()+"," + member.getTeam().getName());
            }
```
+ 현재 지연 로딩이므로, Team을 사용할때 Team과 관련된 쿼리를 날려준다.
+ getTeam()에서 Team의 프록시가 나오고, getName()에서 프록시가 영속성 컨텍스트에 name값을 요청한다. 그러면, DB에서 쿼리가 실행된후 값을 보내준다.
```
            회원1, 팀A - SQL 에서 가져옴
            회원2, 팀A - (컨터이너의 1차캐시에서 가져옴)
            회원3, 팀B - SQL에서 가져옴.
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as team_id5_0_,
            member0_.type as type3_0_,
            member0_.username as username4_0_ 
        from
            Member member0_
Hibernate:         //  필요시 에만 날리는 모습
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_ 
    from
        Team team0_ 
    where
        team0_.id=?
member = 회원1,팀A
member = 회원2,팀A
Hibernate:            //  필요시 에만 날리는 모습
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_ 
    from
        Team team0_ 
    where
        team0_.id=?
member = 회원3,팀B
```
+ 만약 게시판에서 회원이 100명인데 각각 팀이 다르다면 어떻게 될까? -> N+1 문제가 발생.
+ 즉 100번쿼리가 날라가고(각각의 Team), 1의 쿼리가 추가된다( 맨처음의 Member객체에 대한 쿼리)

### 2.1.2엔티티 페치 조인 적용
```java
// --------------------fetch join
            String query =
                    "select m from Member m join fetch m.team"; // left, right 등 outer join가능.
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername()+"," + member.getTeam().getName());
            }
```
+ 이때의 getTeam()으로 얻은 Team은 프록시가 아니라, 진짜 객체 Team을 의미한다.
+ 주로 조회업무를 할때 매우 많이 사용한다.
+ 지연로딩으로 설정해도 fetch join의 우선순위가 더 높다.

> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    from
        Member m 
    join
        fetch m.team */ select
            member0_.id as id1_0_0_,
            team1_.id as id1_3_1_,
            member0_.age as age2_0_0_,
            member0_.TEAM_ID as team_id5_0_0_,
            member0_.type as type3_0_0_,
            member0_.username as username4_0_0_,
            team1_.name as name2_3_1_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.id
member = 회원1,팀A
member = 회원2,팀A
member = 회원3,팀B
```
+ 즉시로딩과 같은 모습이 된다. 중요한건 fetch join을 통해 우리가 필요할때마다 즉시로딩의 쿼리를 생성할수 있다는 것이다.

## 2.2 컬렉션 페치 조인
+ 일대다 관계, 컬렉션 페치 조인
+ JPQL 코드
```sql
select t
from Team t join fetch t.members   // Team 안의 List<Member>(members)와 fetch Join
where t.name = ‘팀A' 
```
+ SQL 결과
```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'
```
### 2.2.1 적용코드
```java
          String query =
                    "select t from Team t join fetch t.members"; // left, right 등 outerjoin가능.
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team객체위치 = " +team + "| team객체이름 = "  + team.getName()+ "| members = " + team.getMembers()); 
                for( Member member : team.getMembers()){   // 예) 팀 A 객체안에 있는 List<Member>
                    System.out.println("----> member = "+member);
                }
            }
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        t 
    from
        Team t 
    join
        fetch t.members */ select
            team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as team_id5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as team_id5_0_0__,
            members1_.id as id1_0_0__ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result.size() = 3
team객체위치 = jpql.Team@60dd0587| team객체이름 = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team객체위치 = jpql.Team@60dd0587| team객체이름 = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team객체위치 = jpql.Team@5edacf20| team객체이름 = 팀B| members = [Member{id=5, username='회원3', age=0}]
----> member = Member{id=5, username='회원3', age=0}
```
+ 그림3
+ 그림4

+ 참고: 이전에 양방향매핑이면, 값이 다 들어가지만 읽기만 가능하게 된다는걸 기억하자. 그래서 편의메서드로 값을 안넣어도 값은 들어간다.(기억회상용)
+ **팀A가 두번 나온 이유**
  - Team 입장에서는 일대다 join이기 때문에 데이터가 뻥튀기 될수 있다.
  - 예를 들어 ID = 1, 팀A 인 Team 객체는 영속성 컨텍스트에 위치하고, 회원1 member, 회원2 member와 fetch join을 하는 하므로, 데이터가 뻥튀기된다.(DB 로직과 유사)
  - 그래서 조회한 List\<Team\> 즉 result에서는 팀A가 두번 출력된다. 이때 이 둘은 같은 영속성 컨텍스트에 위치하고 있는 모습을 확인 할수 있다.
+ **팀A객체의 members가 같은 내용인 이유**
  - fetch join은 fK = pk 인 대상에 대하여 한번에 끌어오도록 join 시켜버리기 때문이다.

## 2.3 페치 조인과 distinct
+ SQL의 DISTINCT는 중복된 결과를 제거하는 명령
+ JPQL의 DISTINCT 2가지 기능 제공
  1. SQL에 DISTINCT를 추가
  2. 애플리케이션에서 엔티티 중복 제거

+ 우리의 경우 1번은 데이터가 다르므로 SQL 결과에서 중복 제거에 실패한다.
+ 그림5

### 2.3.1 엔티티 중복 제거
+ DISTINCT가 추가로 애플리케이션에서 중복 제거시도
+ 같은 식별자를 가진 Team 엔티티 제거
+ 그림6

```java
String query =
                    "select distinct t from Team t join fetch t.members"; // left, right 등 outerjoin가능.
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();

            System.out.println("result.size() = " + result.size());

            for (Team team : result) {
                System.out.println("team = " + team + "| teamname = " + team.getName()+ "| members = " + team.getMembers()); // 팀 A
                for( Member member : team.getMembers()){
                    System.out.println("----> member = "+member);
                }
            }
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        distinct t 
    from
        Team t 
    join
        fetch t.members */ select
            distinct team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as team_id5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as team_id5_0_0__,
            members1_.id as id1_0_0__ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result.size() = 2
team = jpql.Team@221a2068| teamname = 팀A| members = [Member{id=3, username='회원1', age=0}, Member{id=4, username='회원2', age=0}]
----> member = Member{id=3, username='회원1', age=0}
----> member = Member{id=4, username='회원2', age=0}
team = jpql.Team@7e307087| teamname = 팀B| members = [Member{id=5, username='회원3', age=0}]
----> member = Member{id=5, username='회원3', age=0}
```

## 2.4 페치 조인과 일반 조인의 차이
+ 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음.(지연로딩)
+ JPQL 코드
```
select t
from Team t join t.members m
where t.name = ‘팀A' 
```
+ SQL 결과
```sql
SELECT T.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID 
WHERE T.NAME = '팀A'
```
+ JPQL은 결과를 반환할 때 연관관계 고려X 
+ 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.
+ 위코드는 Team 엔티티만 조회하고, 회원 엔티티는 조회X ,
+ 사용시마다 쿼리를 생성하여 조회한다.(지연로딩, N+1의 문제가능성 있음)
****
## 2.5 페치조인 정리
+ 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩) 
+ 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념
+ JPQL코드
```
select t 
from Team t join fetch t.members
where t.name = ‘팀A' 
```
+ SQL결과
```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID 
WHERE T.NAME = '팀A'
```
