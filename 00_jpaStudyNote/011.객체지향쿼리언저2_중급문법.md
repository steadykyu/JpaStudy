# 1. 경로 표현식
## 경로 표현식
+ '.'(점)을 찍어 객체 그래프를 탐색하는 것
+ 그림1

## 경로 표현식 용어정리
+ 상태 필드(state field): 단순히 값을 저장하기 위한 필드
 -(ex: m.username) 
+ 연관 필드(association field): 연관관계를 위한 필드
  - 단일 값 연관 필드:
    - @ManyToOne, @OneToOne, 대상이 **엔티티**(ex: m.team) 
  - 컬렉션 값 연관 필드:
    - @OneToMany, @ManyToMany, 대상이 **컬렉션**(ex: m.orders)

## 경로 표현식 특징
+ 상태 필드(state field): 경로 탐색의 끝, 추가탐색X
+ 단일 값 연관 경로: **묵시적 내부 조인(inner join) 발생**, 추가탐색O 
+ 컬렉션 값 연관 경로: **묵시적 내부 조인 발생**, 추가탐색X 
  - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

> 단일 값 연관 경로 탐색
```java
            Team team = new Team();
            em.persist(team);

            Member member1 = new Member();
            member1.setUsername("관리자1");
            member1.setTeam(team);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("관리자2");
            member2.setTeam(team);
            em.persist(member2);

            em.flush();
            em.clear();

            String query =
                    "select m.team from Member m";
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();
```
> 결과 쿼리
```sql
   /* select
        m.team 
    from
        Member m */ select
            team1_.id as id1_3_,
            team1_.name as name2_3_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.id
```
+ DB입장에서보면 해당 명령을 처리하기위해 묵시적으로 innerjoin이 일어나야한다.
+ 실무적으로 이런 묵시적 innerjoin은 쿼리 튜닝시 많은 어려움을 준다.
+ 추가 탐색이 가능함
```java
String query =
                    "select m.team.id from Member m";       // 엔티티 안의 값을 출력하도록 설정.
            List<Long> result = em.createQuery(query, Long.class)
                    .getResultList();
            for (Long aLong : result) {
                System.out.println("aLong = " + aLong);
            }
// aLong = 1 출력
```

> 컬렉션 값 연관경로
```java
            String query =
                    "select t.members from Team t";
            List<Collection> result = em.createQuery(query,Collection.class)
                    .getResultList();
            System.out.println("result = " + result);
```
```sql
Hibernate: 
    /* select
        t.members 
    from
        Team t */ select
            members1_.id as id1_0_,
            members1_.age as age2_0_,
            members1_.TEAM_ID as team_id5_0_,
            members1_.type as type3_0_,
            members1_.username as username4_0_ 
        from
            Team team0_ 
        inner join
            Member members1_ 
                on team0_.id=members1_.TEAM_ID
result = [Member{id=2, username='관리자1', age=0}, Member{id=3, username='관리자2', age=0}]
```
+ 위 코드처럼 묵시적 innerjoin이 발생하며, 컬렉션 자체를 뽑는건 가능하다.
+ 그러나 추가탐색이 불가능하다고 쓴것과 같이 **컬렉션 안쪽의 값을 select에 꺼낼수가 없다.**
```java
String query = "select t.members.id from Team t"; // 불가능하다!!
```
+ 컬렉션 안의 값을 보고싶다면 아래처럼 명시적 조인을 해주어야한다.
```java
            // 명시적 조인
            String query =
                    "select m.username from Team t join t.members m";
```
### 명시적 조인, 묵시적 조인
+ 명시적 조인: join 키워드 직접 사용(외부, 내부 조인가능)
  - 예) select m from Member m join m.team t
+ 묵시적 조인: 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능) 
  - 예) select m.team from Member m
### 경로 탐색을 사용한 묵시적 조인시 주의사항
+ 항상 내부 조인
+ 컬렉션은 경로 탐색의 끝, 컬렉션 안쪽 값을 얻기 위해서는 명시적 조인을 통해 별칭을 얻어야함
+ 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 **묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌**

### 실무 조언 및 정리
+ **가급적 묵시적 조인 대신에 명시적 조인 사용**
+ 조인은 SQL 튜닝에 중요 포인트
+ 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려우므로 가급적 사용하지 않는다.(쿼리 튜닝시 어려움을 겪음)

