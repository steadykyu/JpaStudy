## 요약

## 1.연관관계 매핑시 고려사항 3가지
+ 다중성
    + 1:1, N:1, N:N 등
+ 단방향, 양방향
+ 연관관계의 주인
    + N쪽이 주인이 되도록한다.

## 2. 다대일 N:1

다대일 단방향이 일반적으로 가장 좋은 설계이다. 비즈니스적으로나 객체설계적으로 꼭 필요한 경우에만 아래 개념들을 적용시킨다.

> 다대일 양방향

외래 키가 있는 쪽이 연관관계의 주인

양쪽을 서로 참조하도록 개발해야한다.

https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/005.%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EB%A7%A4%ED%95%91.md 

> 일대다 단방향

일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인으로 설정하는 것이다. 그런데 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음

유지보수가 어렵고 쿼리 낭비가 일어나므로 사용하지말자.

> 일대다 단방향

공식적으로 인정하지도 않았음. 그냥 다대일 양방향을 사용하자.

## 3. 일대일 1:1 관계
> 특징
일대일 관계는 그 반대도 일대일

주 테이블(자주 사용되는 테이블)이나 대상 테이블 중에 외래 키 선택 가능하다.

> 주 테이블에 외래 키 설정 및 단방향

```java
@Entity
public class Member {
    @OneToOne
    @JoinColumn(name = "LOCKER_ID")         //
    private Locker locker;
    }
```
> 주 테이블에 외래 키 양방향

Member 객체 생성에 이어서 아래 Locker 객체 생성해준다.
```java
@Entity
public class Locker {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToOne(mappedBy = "locker")      // mappedBy 추가!
    private Member member;
}
```
Member Table 속에 LOCKER_ID가 존재하고 있다. 즉 외래키가 존재한다!. 다대일 과 같이 외래키가 존재하는 쪽을 주인으로 설정하면 된다.

주 객체가 대상 객체의 참조값을 가지고 있는것 처럼, 주 테이블도 외래키를 가지고 대상 테이블을 조회할 수 있다.

JPA 매핑과정이 일치해지므로 편리하다. 그러므로 객체지향의 개발자들이 선호한다. 

일반적으로는 주 테이블에 외래키를 두는 것이 좋다.

> 대상 테이블에 외래 키

주 테이블에 작업한 소스코드 작업을 대상 테이블에 해주면 된다.

대상 테이블에 외래키가 존재하여, 주 테이블과 대상테이블을 일대일에서 일대다 관계로 변경할때 테이블 구조 유지가 편하다.

그러므로 전통적인 DB개발자들이 선호한다.

## 4. 다대다 매핑(N:M)
> 테이블 관점
관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음. 그러므로 두 테이블 사이에 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함.

> 객체 관점
객체는 서로 컬렉션을 사용해서 객체 2개로 다대다 관계 가능하다.
> 구현
```java
@Entity
public class Member {
    @ManyToMany
    @JoinTable(name="MEMBER_PRODUCT")                   // MEMBER_PRODUCT 이 생성되고 값이 들어간다.
    private List<Product> products = new ArrayList<>();
    (...)
-----------------------------------------------------------
@Entity
public class Product {
    @ManyToMany(mappedBy = "products")
    private List<Member> members = new ArrayList<>();
    (...)
```
단방향과 양방향 모두가능하다.

> 다대다 매핑의 한계


1. 다대다 매핑은 필드 추가가 불가능하다.

실무에서는 연결 테이블이 단순히 연결만 하고 끝나지 않는다. 주문시간, 수량 같은 데이터가 새로 들어오는 필드를 추가해주는 상황이 온다.

2. DB 관계로 본다면 중간에 테이블에 숨겨져 있는 상태이므로, 예상하지 못한 쿼리가 나갈 수 있다.

> 다대다 매핑의 한계 극복

다대다 매핑은 다대일 매핑을 두번하는 연결테이블용 엔티티(MemberProduct)를 추가해서 작업한다.

N:M -> 1:N M:1 의 관계
```java
@Entity
public class MemberProduct {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    
    private Product product;                // 새로운 필드들(테이블column) 추가가능!

    private int count;
    private int price;

    private LocalDateTime orderDateTime;
}
```

***
## 연관관계 매핑시 고려사항 3가지
+ 다중성
+ 단방향, 양방향
+ 연관관계의 주인

### 다중성
> 앞으로 나올 내용으로, 앞글자가 해당 엔티티의 관계를 의미한다.
+ 다대일: @ManyToOne 
+ 일대다: @OneToMany 
+ 일대일: @OneToOne 
+ 다대다: @ManyToMany

### 단방향, 양방향
> 테이블 관점
 
+ 외래 키 하나로 양쪽 조인 가능
+ 사실 방향이라는 개념이 없음

> 객체 관점

+ 참조용 필드가 있는 쪽으로만 참조 가능
+ 한쪽만 참조하면 단방향
+ 양쪽이 서로 참조하면 양방향(양방향 보다는 서로 단방향인 개념)

### 연관관계 주인
+ 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
+ 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데이다. 그러므로 둘중 테이블의 외래 키를 관리할 곳을 지정해야함.
+ 연관관계의 주인: 외래 키를 관리하는 참조( '다' 쪽에 놔야함)
+ 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 1.다대일 N:1
### 다대일 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_1.png">

+ 가장 많이 사용하는 연관관계
+ 다대일의 반대는 일대다
### 다대일 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_2.png">

+ 외래 키가 있는 쪽이 연관관계의 주인
+ 양쪽을 서로 참조하도록 개발

## 1.일대다 1:N
> 코드
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;

    @OneToMany                   
    @JoinColumn(name = "TEAM_ID")                     //Team쪽에 연관관계 매핑을 위한 JoinColumn이 들어간다.
    private List<Member> members = new ArrayList<>();
```
Team쪽에 @JoinColumn(name = "TEAM_ID")를 추가하고 Member쪽의 team 참조변수를 없앤다.
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_3.png">

### 일대다 단방향 정리
+ 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
+ 테이블 일대다 관계는 **항상 다(N)** 쪽에 외래 키가 있음
```
TABLE입장에서는 MEMBER_ID  FK가 되버리면 중복되는 ROW들이 생기므로 구별이 불가능해진다. 
그러므로 무조건 MEMBER에 FK가 있어야한다.
```
+ 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
+ @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함
```
@JoinColumn을 없을시 두 테이블을 Join 시켜 거대한 새로운 TABLE(Member_Team)을 만들어서 작업한다.
```
+ 일대다 단방향 매핑의 단점
```
엔티티가 관리하는 외래 키가 다른 테이블에 있음

연관관계 관리를 위해 commit()시 추가로 MEMBER TABLE에 UPDATE SQL쿼리를 날리고 실행
    - List에 있는 Member객체를 하나하나 전부 다 update해야함.
```
+ 왠만하면 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

### 일대다 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_4.png">

### 일대다 양방향 정리
+ 이런 매핑은 공식적으로 존재X 
+ @JoinColumn(insertable=false, updatable=false)으로 필드를 읽기 전용필드를 만들수 있다.
+ 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
+ 왠만하면 다대일 양방향을 사용하자

## 3.일대일 1:1
+ 일대일 관계는 그 반대도 일대일
+ 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
```
주 테이블에 외래 키
대상 테이블에 외래 키
주 테이블 : 주로 access(select) 하는 테이블
```
• 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

### 일대일: 주 테이블에 외래 키 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_5.png">

+ 다대일(@ManyToOne) 단방향 매핑과 유사
+ 코드작업
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")         //
    private Locker locker;
    (...)
```
### 일대일: 주 테이블에 외래 키 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_6.png">

+ 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인
+ 반대편은 mappedBy 적용
+ 코드작업
```
@Entity
public class Locker {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToOne(mappedBy = "locker")      // mappedBy 추가!
    private Member member;
}
```
### 일대일: 대상 테이블에 외래 키 단방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_7.png">

+ 단방향 관계는 JPA 지원X
+ FK를 이동시키는 양방향 관계는 지원
### 일대일: 대상 테이블에 외래 키 양방향
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_8.png">

+ 사실 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음(FK만 이동한것)

### 일대일 정리
> 주 테이블에 외래 키
+ 일대일: 주 테이블에 외래 키 양방향 그림참고
```
• 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
• 객체지향 개발자 선호
• JPA 매핑 편리
• 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
• 단점: 값이 없으면 외래 키에 null 허용
```
> 대상 테이블에 외래 키
+ 일대일: 대상 테이블에 외래 키 양방 그림참고
```
• 대상 테이블에 외래 키가 존재
• 전통적인 데이터베이스 개발자 선호
• 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
• 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)
```
## 1.다대다 N:M
### 다대다
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_9.png">

+ 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
+ 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
+ 객체는 서로 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
```java
@Entity
public class Member {
    @ManyToMany
    @JoinTable(name="MEMBER_PRODUCT")                   // MEMBER_PRODUCT 이 생성되고 값이 들어간다.
    private List<Product> products = new ArrayList<>();
    (...)
-----------------------------------------------------------
@Entity
public class Product {
    @ManyToMany(mappedBy = "products")
    private List<Member> members = new ArrayList<>();
    (...)
```
+  다대다 매핑: 단방향, 양방향 가능

### 다대다 매핑의 한계
+ 편리해 보이지만 실무에서 사용X 
+ 실무에서는 연결 테이블이 단순히 연결만 하고 끝나지 않는다. 주문시간, 수량 같은 데이터가 들어올 수 있음
+ 다대다 매핑에서는 추가가 불가능하다.
+ 다대다 매핑을 위해 생성한 중간테이블로 인해 쿼리가 복잡한 모양으로 생성된다.

### 다대다 한계 극복
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_10.png">

+ 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) 
+ @ManyToMany 대신 연결 테이블용 엔티티에 @OneToMany, @ManyToOne을 추가한다.
+ Member와 Product에 읽기 전용의 참조변수를 추가하고 mappedby해준다.
```java
@Entity
public class MemberProduct {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    
    private Product product;                // 새로운 필드들(테이블column) 추가가능!

    private int count;
    private int price;

    private LocalDateTime orderDateTime;
}
```
+ 운영적으로 가운데 테이블의 pk 와 fk는 따로 두는게 시스템을 유연하게 만들수 있다.(나중에 나옴)

## 4. 실전
코드 작업밖에 없어서 추가 자료를 첨부한다.
### 여러 옵션들의 속성
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_11.png">

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_12.png">

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/6_13.png">
