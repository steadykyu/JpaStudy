# 요약
## 1. 연관관계 매핑이 필요한 이유
이전까지 객체와 테이블을 매핑시켜왔다. 그러나 객체들끼리 참조할수 없었다. 객체와 DB 사이에도 객체지향적인 설계가 필요하다.

이를 위한 단방향 연관관계와 양방향 연관관계가 존재한다.

## 2. 단방향 연관관계
> 단방향
```java
class Member{
    @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;
}
```
## 3. 양방향 연관 관계
> 양방향
```java
class Member{
    @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;
}
// 단방향과 같음

class Team{
    @OneToMany(mappedBy = "team") // Team입장에선 1대n관계
    private List<Member> members = new ArrayList<>();
}
```
실제 설계는 단방향 매핑만으로 구성해두고 추가로 필요한 부분에 양방향 매핑을 하는 것이 좋다.

양방향 매핑에서는 연관관계 주인을 꼭 설정해주어야 한다. 이때 외래키를 가지고 있는 N의 관계에 주인을 설정해주면 된다.

이로써 주인쪽에서 값을 변경시, 주인이 아닌쪽에서 알아서 값 변경이 된 모습을 확일 할수 있따. 단 주인이 아닌쪽은 값을 조회할 수만 있을뿐 변경은 불가능하다.

> JPA가 동작하지 않는 상황일때의 양방향 연관관계

flush()나 commit()이 실행되지 않아 매핑이 되지 않은 경우 ,또는 테스트코드와 같이 JPA가 동작하지 않는 경우에도 코드를 실행해야하는 상황이 있다.

이때 위처럼 소스코드를 작성하면, 서로 객체 참조가 불가능해진다. 그러므로 참조하는 객체 모두(주인과 주인이 아닌쪽)에게 값을 넣어주어야 문제가 발생하지 않는다. 
```java
member.setTeam(team); / team.getMembers().add(member); 
```
이를 누락하지 않기 위해 편의메소드를 사용하면 값 주입 누락을 막을 수 있다.
```java
public class Member{
    public void changeTeam(Team team) {
            this.team = team;
            team.getMembers().add(this);
        }
        ...
}
---------------------------------------------
public class Team{
    public void addMember(Member member){
            member.setTeam(this);
            members.add(member);
        } 
}
```
# 1.연관관계 매핑 기초

## 연관관계가 필요한 이유
+ 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. 즉 객체지향 설계를 위해서 필요하다.

## 예제 시나리오
```
• 회원과 팀이 있다. 
• 회원은 하나의 팀에만 소속될 수 있다. 
• 회원과 팀은 다대일 관계다
```

## 1.1객체를 테이블에 맞추어 모델링
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_1.png">

+ FK(외래키)가 존재한다는 것은 한 FK에 여러 PK가 있을수 있다는 뜻이다.(TeamA : Member1, Member2)
+ 즉 1대 N의 관계라는 것이다.
+ 객체를 필드로 가지고 있지 않으므로 서로 참조 할수 없는 객체의 모습을 보이고 있다.

### 코드작업
> Member
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

      @Column(name = "TEAM_ID")
    private Long teamId;
    
    (+ getter , setter)
```
> Team
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;
    (+ getter , setter)
```
> 실행파일
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeamId(team.getId());                             // 외래키값을 직접 저장
            em.persist(member);

            Member findMember = em.find(Member.class, member.getId());  // 값 조회 / id=1이 들어가있음
            Long findTeamId  = findMember.getTeamId();                  // 외래키값을 꺼냄.

            Team findTeam = em.find(Team.class, findTeamId);            // 외래키값으로 조회
            findTeam.getId();                                           // 팀의 아이디를 얻음.
            tx.commit();
            (....)
```
+ 외래 키 식별자를 직접 다루어 저장한다.
+ Member 객체를 통해 Team 객체속 teamID를 조회 하려고 하면 외래키 식별자(Member.getTeamId() 로 team_id)구해야 하고, 그대로의 값으로 사용한다는 단점이 있다.
+ 참조할수 없기때문에 id=1인 member의 TeamId 그리고 TeamName을 얻기위해서는 JPA를 거쳐 DB에서 두번이나 find()해와야한다.

> 결국 **협력관계**를 만들수 없다.
```
• 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다. 
• 객체는 참조를 사용해서 연관된 객체를 찾고있다.
     - 그런데 위코드는 참조가 아닌 외래키를 값을 직접 구해서 연관 테이블을 찾고있다.
• 테이블과 객체 사이에는 이런 큰 간격이 있다.
```
## 1.2 단방향 연관관계
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_2.png">

> 멤버
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
    }
```
+ Member 입장에서 Team과 N:1이므로 @ManyToOne을 추가하여 JPA와 DB에 관계를 알려준다.

+ 그리고 Team객체 참조값(team)과 TEAM_ID(FK)를 @JoinColumn(name = "TEAM_ID")으로 매핑시켜준다.
(외래키 매핑)
+ DB에서 MEMBER와 TEAM 테이블을 Join 시켜주는 컬럼을 알려준다.

+ 앞으로 JPA에서 애노테이션들은 거의 다 DB에게 옵션이나 값을 지정해주는 역할을 자주 볼 것이다.

> 실행
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        // 관리자를 새로 만들기.(아래 코드입장에서는 계속 em과 트랜잭션이 새로 만들어 지는 것이다.)
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);                   // 단방향 연관관계 설정, 참조 저장                                  
            em.persist(member);                     // JPA가  자동으로 team에서 pk값을 꺼낸후, insert쿼리 동작시 FK(외래키)값으로 사용한다.
            
            em.flush();                             // 쿼리를 DB에 보낸다.
            em.clear();                             // 영속성 컨테이너를 비워준다.
           
            Member findMember = em.find(Member.class, member.getId());
            Team findTeam  = findMember.getTeam();                    // 참조를 통해 연관된 객체를 찾는모습
            System.out.println("findTeam = " + findTeam.getName());   // findTeam 참조변수를 통해 팀의 이름(TeamA)를 얻어옴.
            tx.commit() 
            ...
```
+ 저장 : member.setTeam(team); 을 통해 Member의 team 필드에 (Team객체의)참조값 저장된다.
+ 이제 마치 Java에서 객체를 다루듯이 사용하면, 적절하게 테이블 작업이 되는 것이다!!
+ flush() : 원래는 1차캐시에서 값을 가져오고 커밋후 쿼리를 날리지만, flush()와 clear()를 하면 커밋 전에 쿼리를 DB에 날리고, 영속성 컨테이너의 값을 지울 수 있다.
> 영속성 컨텍스트가 날린 쿼리를 살펴보자.
```sql
Hibernate: 
    select
        member0_.MEMBER_ID as MEMBER_I1_0_0_,
        member0_.TEAM_ID as TEAM_ID3_0_0_,
        member0_.USERNAME as USERNAME2_0_0_,
        team1_.TEAM_ID as TEAM_ID1_1_1_,
        team1_.name as name2_1_1_ 
    from
        Member member0_ 
    left outer join
        Team team1_ 
            on member0_.TEAM_ID=team1_.TEAM_ID 
    where
        member0_.MEMBER_ID=?
```
+ Join TABLE을 생성하는 쿼리를 날리는 모습을 볼 수 있다.
+ 조회 : 이전과 다르게, member값 찾을때 DB에서 조회하는데, findMember참조변수를 통해 team객체값을 얻어올 수 있다.
+ 마치 연결된 DB에서 값을 가져오듯이 findMember가 가리키는  Member객체안에 Team 객체가 저장되어있다.
+ 결론적으로 테이블끼리 FK로 연결되어 JOIN TABLE을 만든 것을 객체의 참조방식으로 구현한 것이다.

## 1.3 연관관계 수정
```java
           // ---------------------------연관관계 수정
            Team team2 = new Team();
            team2.setName("TeamB");
            em.persist(team2);
            findMember.setTeam(team2);                // 기존의 findMember의 연관관계가 수정된다.
            Team findTeam2  = findMember.getTeam();                   // TeamA였던 findMember는 이제
            System.out.println("findTeam = " + findTeam2.getName());  // TeamB 로 출력된다.
```
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_3.png">

+ findMember, MEMBER TALBE에 존재하는 row는 TEAM_ID가 1에서 3으로 변경된 것이다.
+ TEAM_ID를 통해 JOIN하여 그 안의 NAME을 꺼내오는 과정을 객체 참조의 과정으로 만들어 내고 있다.
> 참고
@GeneratedValue로 같은 시퀀스를 쓰고 있기 때문에, ID값이 DB값처럼 들어갔다.

# 2. 양방향 연관관계와 연관관계의 주인-기본
+ 위에서 Member객체에서 Team으로는 갈수 있는데, 반대로 Team에서도 Member객체로 가게 해주고싶다.
+ 그럴때 객체는 양방향 매핑을 사용하면 된다.
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_4.png">

## 2.1 테이블 연관관계

- 테이블 연관관계에서 MEMBER에서 TEAM을 얻고싶으면 TEAM_ID로 JOIN하면 되고, 반대로 TEAM에서 MEMBER를 알고 싶어도 TEAM_ID로 JOIN하면된다.

- 멤버가 어떤팀인지 알고싶은거랑, 팀에 어떤멤버가있는지는 둘다 테이블JOIN을 하면 구할 수 있다.

- 즉 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리

- MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐(양방향이긴 하지만 사실 없는 느낌이 강함)

## 2.2 객체 연관관계

- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단뱡향 관계 2개다.

### 코드작업
> Team에 매핑 추가
```java
@Entity
public class Team {

    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")                     // Team입장에선 1대n관계
    private List<Member> members = new ArrayList<>(); // 관례로 이렇게 초기화함.
    (....getter setter)
```
+ mappedBy
``` 
- 멤버 변수가 반대편 객체에서 매핑하고 있는 변수를 넣어준다.
- 양방향 매핑일 경우 매핑을 담당하는 반대쪽 참조변수가 들어가면 된다.
```
> 실행
```java
public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);   
            em.persist(member);

            em.flush();
            em.clear();

            Member findMember = em.find(Member.class, member.getId());
            List<Member> members = findMember.getTeam().getMembers();       // 역방향 
            for(Member m : members){
                System.out.println("m = "+ m.getUsername());
            }

            tx.commit();
```
+ 결과 m = member1;

### 둘 중 하나로 외래키를 관리해야한다.
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_5.png">

```
즉 만약 한 멤버가 팀을 바꾸고 싶은 상황이라면, team을 수정해야할까 아니면 members를 수정해야할까 고민이 생긴다.
둘다 맞는말이나 db는 그저 fk만 잘 수정되면 된다. 근데 외래키는 어떻게 업데이트 해야할까?
```

## 2.3. 연관관계의 주인-Owner
### 양방향 매핑 규칙
```
• 객체의 두 관계중 "하나를" 연관관계의 주인으로 지정
• 연관관계의 주인만이 외래 키를 관리(등록, 수정) 
• 주인이 아닌쪽은 읽기만 가능
• 주인은 mappedBy 속성 사용 X 
• 주인이 아니면 mappedBy 속성으로 주인 지정
```

### 누구를 주인으로?
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_6.png">

+ 여기서는 Member.team이 연관관계의 주인이다.
+ 즉 Team의 members는 값을 조회만 가능하지, 값 등록, 수정이 불가능하다.
+ ***외래 키가 있는 있는 곳을 주인으로 정해라. 1:N 에서 N 쪽이 외래키가 존재하는 곳이다.***
> 이유

1. DB입장에서 보면 외래키가 있는 곳이 무조건 N, 아닌쪽이 1이다. 이말은 DB N쪽이 연관관계 주인이 된다는 것이다.(ManytoOne 쪽)
2. 연관관계의 주인은 비즈니스적으로는 도움되지는 않는다.
     ex) 자동차와 바퀴중 자동차가 비즈니스적으로 중요한데, 바퀴가 연관관계 주인이 되어야한다.

만약 한 memberA의 Team이 바뀌었다고 가정해보자.
3. N의 관계인 Member의 Team이 바뀌면, 참조값 team만 수정해주면 된다. 그러면 DB에서도 MEMBER 테이블의 FK값이 알아서 바뀌므로 설계가 깔끔해진다.
```java
class Member{
    Team team;
}
-------------
class team{
    List<Member> members;
}
```
4. 만약 반대로 members가 주인이라면, Team 클래스속 members 수정시 DB속의 TEAM 테이블 뿐만아니라 관련된 테이블인 MEMBER DB를 찾아서 수정해주는 쿼리가 나간다. 이는 복잡한 상황을 만들뿐더러, 성능 저하도 일으킨다.

# 3. 양방향 연관관계와 연관관계의 주인 2 - 주의점,정리
### 3.1 연관관계의 주인에 값을 입력하지 않을경우
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_7.png">

+ team.getMembers().add(member);는 읽기전용이라 JPA 사용하지않기 때문에 null이 들어간다.
+ member.setTeam(team); 처럼 주인관계에 연관관계가 들어가야 한다.

### 3.2 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.
### flush()와 clear()가 있는경우
> 수정코드
```java
Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);                   // 주인에다 값을 넣어보자.
            em.persist(member);

//            team.getMembers().add(member);       // 주인이 아닌쪽에서 값을 넣는 경우
            em.flush();
            em.clear();

            Team findTeam = em.find(Team.class, team.getId());
            List<Member> members = findTeam.getMembers();
            System.out.println("==========");
            for(Member m : members){
                System.out.println("m = "+ m.getUsername());
            }
            System.out.println("==========");
```
> 결과값 및 쿼리
```
==========
Hibernate: 
    select
        members0_.TEAM_ID as TEAM_ID3_0_0_,
        members0_.MEMBER_ID as MEMBER_I1_0_0_,
        members0_.MEMBER_ID as MEMBER_I1_0_1_,
        members0_.TEAM_ID as TEAM_ID3_0_1_,
        members0_.USERNAME as USERNAME2_0_1_ 
    from
        Member members0_ 
    where
        members0_.TEAM_ID=?
m = member1                             //결과값 출력확인
==========
```
+ member.setTeam(team); 주인에게 값을 넣어주고, list에는 값을 넣어주지 않았지만 결과 값은 출력이 된다.
+ 쿼리 결과를 보면 우리가 for문에서 m.getUsername 시점에 JPA에서 FK 정보를 가지고 쿼리를 날리고 있다.
+ flush() clear()이후 DB에서 다시 조회해오기 때문에 JPA가 FK의 존재도 알고, 다른 여러 값(list포함)들을 한번에 다 조회하는 매커니즘이 동작한 것이다.
+ 그리고 team.getMembers().add(member); 로 값을 넣어도 결과가 달라지지 않는다.(JPA가 사용하지 않기때문)

### flush()와 clear()가 없는경우
> for문 결과값
```
==========
==========
```
+ flush(), clear() 가 사라진다면, persist() 한 값들이 1차캐시에 저장되어 커밋전까지 메모리에서 값을 가져올 것이다.
+ 이 경우 쿼리가 날라오지않고, team과 Member는 매핑상태가 아닌 순수한 객체상태처럼 1차캐시에 존재한다.
+ 매핑되지 않았으므로 findTeam.getMembers(); 호출하더라도 members에 값이 존재하지 않는다. 

### 순수한 객체 관계를 고려하여 양쪽다 값을 입력하는 이유
1. 위의 사고를 막고 조금더 객체지향적으로 생각한다면 양쪽에 다 값을 입력해주는 것이 좋다.
2. 특히 테스트 케이스 작성시에는 JPA 없이도 java코드를 동작시켜야 할때가 있따. 그런 상황일때 위 처럼 작성한다면 객체 참조에러로 테스트에러가 발생한다.

### 3.3 양방향 연관관계 주의
+ 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
+ 연관관계 편의 메소드를 생성하자
```
 - member.setTeam(team); / team.getMembers().add(member); 
 - 양쪽다 넣는 과정에서 실수로 입력하지 않을 확률이 높다.
 - 그러므로 아래처럼 편의 메서드를 통해 값을 입력해주면 입력하지 않을 문제를 막을 수 있다.
 - 어느쪽을 입력해도 상관 없으나, 무조건 둘중 "하나만" 선택해서 값을 세팅해야 충돌이 발생하지 않는다.
 - 일부로 이 작업은 명시적으로 중요한 메서드임을 보이기위해 getter setter로 하지 않고 changeTeam, addMember 같은 메서드를 만드는 것이 좋다.
```
> 편의 메소드
```
public class Member{
    public void changeTeam(Team team) {
            this.team = team;
            team.getMembers().add(this);
        }
        ...
}
----------------------또는--------------------
public class Team{
    public void addMember(Member member){
            member.setTeam(this);
            members.add(member);
        } 
}
```
+ 양방향 매핑시에 무한 루프를 조심하자
 예: toString(), lombok, JSON 생성 라이브러리
```java
public class Member{
    @Override
    public String toString() {
        return "Member{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", team=" + team +
                '}';
        // team.toString(); 사용 X
    }
}
---------------------------------------------
public class Team{
    public String toString() {
            return "Team{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", members=" + members +
                    '}';
    }
}
```
+ 위와같이 team, members 참조변수속 객체들을 사용하는 과정에서 무한루프가 발생할 수 있다.
+ 예: toString(), lombok, JSON 생성 라이브러리
+ 양방향 매핑시에는 toString(), lombok은 쓰지말자.

### 3.4 양방향 매핑 정리
+ 단방향 매핑만으로도 이미 연관관계 매핑은 완료된 것이다.
    -  사실 설계때 단방향 설계만으로 완성하는 것이 좋다.
    -  객체만으로만 설계하려고 하면 안된다. 테이블 설계를 머리속으로 그리면서 FK를 신경쓰며 객체설계를 들어가야한다. 
+ 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐, 큰 이점이 있는것은 아니다.
+ 실무에서는 JPQL에서 역방향으로 참조하고 탐색할 일이 꽤 있음.
+ 단방향 매핑을 잘 하고 양방향은 필요할 때 자바코드만 추가하는 방식이 이상적(테이블에 영향을 주지 않음)

### 3.5 연관관계의 주인을 정하는 기준
+ 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
+ 연관관계의 주인은 **외래 키의 위치**를 기준으로 정해야함(1:N에서 N쪽)
    - 운영관계에서도 좋고, DB설계도 쉽고, 성능도 더 좋다. 
    - JPA가 동작하지 않는 상황에서 값을 넣어야할때는 연관관계 편의메서드를 사용하면 된다.

# 4. 실전 예제
## 4.1 
<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_8.png">

+ 우리는 단방향매핑으로 설계해줄 것이기 때문에, FK에 애노테이션만 잘 입력해주면 된다. 
+ ORDERS입장에서 MEMBER와 N:1이므로, 그리고 외래키 지정을 위해  아래 두코드를 입력해준다.
```java
@Entity
@Table(name ="ORDERS")
public class Order {

    (.......)
    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;// 객체지향적이기 위해 Member추가.
    
    (getter setter 추가)
}
```
+ 단방향연관관계 완료
> N의 관계인 OrderItem에도 작업해준다.
```java
@Entity
public class OrderItem {
    @ManyToOne
    @JoinColumn(name="ORDER_ID")
    private Order order;        // Order 와 fK 용 객체 생성

    @ManyToOne
    @JoinColumn(name = "ITEM_ID") // ITEM 와 fK 용 객체 생성
    private Item item;
```

<img src="https://github.com/steadykyu/JpaStudy/blob/master/00_jpaStudyNote/image/5_9.png">

+ 진하게 칠해진 부분의 변수가 참조변수이다.
+ Member 객체는 Orders와 1:N 에서 1이므로 아래코드로 양방향 매핑시켜주자.
+ Orders와 Item의 다대다 매핑은 그림처럼 1:N - N:1 로 표현할 수 있다.
```java
@Entity
public class Member {

    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<>();
    (..........)
    
}
------------------------------
public class Order {
    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();
      (..........)
    
    public void addOrderItem(OrderItem orderItem){
    orderItems.add(orderItem);
    orderItem.setOrder(this);
}
}
```
+ 관례적으로 ArrayList를 만든다.
+ 이제 Member와 Order / Order와 OrderItem이 양방향 매핑되었다.
+ 편의메서드를 Order에 만들어 순수한 객체관계를 고려하여 양쪽에 값을 넣어준다.

## 4.2 양방향 매핑 필요할까?
+ 주문을 통해 상품들을 볼일은 많지만, 상품을 보고 어떤주문들이 있었는지는 실시간 APP제작에 있어서는 그닥 도움이 되지않는다. (나중에 DB에서 통계분석할때는 유의)
+ 그래서 OrderItem과 Item은 양방향 매핑을 굳이 해주지 않는다.
+ 예시를 위해 Member와 Order도 양방향 매핑을 했지만 실무적으로는 좋은 설계가 아니다.

> 특정회원의 주문내역을 보고싶다면?
```
- Order객체를 생성하면서 관련 인스턴스 변수값들을 넣어주고 조회하는 것이 좋다.
- 즉 Order의 FK(member)를 참조를 통해 특정회원의 주문을 조회하는게 좋은 설계다.
- 굳이 따로 Member객체를 만들어서 orders 변수를 통해 order를 조회하는건 좋은 설계가 아니다.
- 객체지향입장에서는 회원입장에서도 주문들을 조회할수 있는점이 좋아보이지만, 이러면 업무량이 너무 많아진다.
- 그래서 연관관계를 잘 끊어내는게 매우 중요하다. 
```

## 4.3 양방향 매핑을 쓰는 이유
+ 위만 보면 그렇게 필요하지 않을 것 같은데, 언제써야하는 걸까?
```
- 개발환경에 있어서 조금 더 편의
- 편하게 조회하고 싶어서
- 실무에서 복잡한 JPQL을 짜다보면 양방향매핑의 ArrayList를 사용해야할때가 있다. 
- 조금 더 객체지향스럽게 하기위해서, 비즈니스적으로 양방향이 필요할 때가 있다.
```
+ 그렇지만 결론적으로는 단방향 매핑으로 설계 할수 있으면 단방향 매핑으로 설계하는게 더 좋다.
+ 아직은 내가 좀더 실무적인 방향을 몰라서, 약간 이해가 부족해보인다. 하나하나 실무해보면서 내용 수정해보자.


```
