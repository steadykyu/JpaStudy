# 1.프록시
## 왜쓰는걸까?
```java
public void printUserAndTeam(String memberId) {
   Member member = em.find(Member.class, memberId);
   Team team = member.getTeam();
   System.out.println("회원 이름: " + member.getUsername()); 
   System.out.println("소속팀: " + team.getName()); 
}
```
+ 회원과 팀을 함께 출력할때는 find메서드로 Member 엔티티속 team을 이용하여 (MEMBER, TEAM)을 join한 쿼리를 통해 값을 가져오면 될것이다.

```java
public void printUser(String memberId) {
 Member member = em.find(Member.class, memberId);
 Team team = member.getTeam();
 System.out.println("회원 이름: " + member.getUsername());  // 영속성 컨텍스트에 존재하는 MEMBER에서 조회 가능함.
}
```
+ 그러나 만약 회원만 출력하고 싶다면, 굳이 Team객체와, DB에서 TEAM 테이블을 join 하는 쿼리가 필요할까?
+ 오히려 굳이 DB에서 여러 자원을 꺼내오므로, 자원의 낭비일 것이다.
+ 그러므로 프록시를 사용한다.

## 프록시 기초
- em.find() vs em.getReference() 
- em.find(): 데이터베이스를 통해서 **실제 엔티티 객체** 조회
- em.getReference(): 데이터베이스 조회를 미루는 **가짜(프록시)를 생성하고, 필요시 엔티티 객체 조회**
+ 그림1
```java
            Member member = new Member();
            member.setUsername("hello");

            em.persist(member);

            em.flush(); // 커밋전에 쿼리를 출력한다.
            em.clear();

//            Member findMember = em.find(Member.class, member.getId());
            Member findMember = em.getReference(Member.class, member.getId());              // find 대신 getReference

//            System.out.println("findMember.getId() = " + findMember.getId());             // 쿼리 생성x 
//            System.out.println("findMember.getUsername() = " + findMember.getUsername()); // join 쿼리 생성
            System.out.println("findMember = " + findMember.getClass());                    // findMember = class hellojpa.Member$HibernateProxy$lVigPKrS
```
+ 위 코드의 getReference를 만들었을때는 프록시 껍데기만 만들었기때문에, 쿼리를 생성하지 않는다.
+ 우리가 getReference() 할때 id값을 넣어주었었다. 그러므로 id만 사용시에는 쿼리가 안나가고 영속성 컨텍스트에서 값을 조회한다.
+ Username을 사용할 시에는 DB에 있는 Username을 찾아오기 위해, DB에 쿼리를 날리고 프록시가 Member 엔티티의 값을 참조해온다.
(디테일하게는 아래 프록시 객체의 초기화를 참고하자)
+ getClass()로 프록시 주소를 알수 있다.

## 프록시 특징
+ 그림 2
+ 실제 클래스를 상속 받아서 만들어짐
+ 실제 클래스와 겉 모양이 같다. 
+ 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상-JPA가 그렇게 구현해 두었다.) 
****
+그림 3
+ 프록시 객체는 실제 객체의 참조(target)를 보관
+ 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

## 프록시 객체의 초기화
+ 그림 4
+ MemberProxy에 target에 Name값이 없으므로 초기화를 요청한다.
+ 이후 DB에서 조회해와서(select 쿼리가 생성), 참조변수 target이 Member 엔티티를 가리키도록 만든다.
+ 한번 초기화하면 이제 target참조변수에서 엔티티를 가리키고 있기때문에 추가로 초기화 하지않아도 된다.

## 프록시의 특징 심화
+ 프록시 객체는 처음 사용할 때 한 번만 초기화
```
(위 코드에서 추가작업...)
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리생성
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리를 생성하지않음.
==========================================================
 - 두번 사용해도 한번만 초기화하면 프록시의 참조로 영속성 컨텍스트에 존재하는 원본 엔티티에서 값을 찾아올 수 있다.
```
+ 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
```
System.out.println("beforefindMember = " + findMember.getClass());    // beforefindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
System.out.println("findMember.getUsername() = " + findMember.getUsername());
System.out.println("afterfindMember = " + findMember.getClass());     // afteffindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
==============================================
 - 초기화 전, 후 같은 프록시 값을 가지고 있다.
```
+ 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용) 
```
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("member2");
            em.persist(member2);

            em.flush();
            em.clear();
// -------------------------1. 두 참조변수가 find로 엔티티를 조회했을 경우
//            Member m1 = em.find(Member.class, member1.getId());
//            Member m2 = em.find(Member.class, member2.getId());
//            System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // 같은 엔티티이므로 같은타입이다.

// -------------------------2. 참조변수가 각각의 엔티티, 프록시를 조회했을 경우
            Member m1 = em.find(Member.class, member1.getId());           // 엔티티객체를 의미
            Member m2 = em.getReference(Member.class, member2.getId());   // 프록시를 의미
            logic(m1,m2);
======================================================
    private static void logic(Member m1, Member m2) {
        // System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // (false)다른타입이다.(객체와 프록시)
        
        // m1, m2가프록시값이든, 객체값이든 일치
        System.out.println("m1 == m2 : " + (m1 instanceof Member)); // 이런식으로 비교가능(true)
        System.out.println("m1 == m2 : " + (m2 instanceof Member)); // 이런식으로 비교가능(true)
    }
```
+ 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다.
```java
// 선엔티티 후 프록시
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member m1 = em.find(Member.class, member1.getId());

            Member reference = em.getReference(Member.class, member1.getId());
            System.out.println("reference.getClass() = " + reference.getClass());  // reference.getClass() = class hellojpa.Member
            System.out.println("a == a" + (m1 == reference));  
            //reference가 프록시가 아닌 Member엔티티로 나온다.
```
> 근거
```
이유1 : 어차피 Member 원본이 1차 캐시(영속성 컨텍스트)에 등록되어있으므로 가져오기만하면 된다.
이유2 : JPA에서 한 트랜잭션안의 영속성 컨텍스트는 m1이 객체든 프록시든 일치하게 만들도록 작동한다.
       (여러 참조변수로 자바 컬렉션 안쪽 같은 객체를 참조하면, 두 참조변수는 일치하는 로직을 가지는 것과 비슷하다.)
================================================================================================================================================
만약 위 참조변수 m1과 reference가 둘다 em.getReference()로 프록시를 가지고 있다면 어떻게 될까?
JPA 로직에 따라 둘다 프록시 Class를 가지며, 영속성컨텍스트에서 == 관계를 가진다.
================================================================================================================================================
```
+ 만약 반대순서로 프록시가 먼저 만들어지고 초기화를 작업하면 어떻게 될까?
```java
// 선프록시 , 후엔티티
 Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("m1 = " + refMember.getClass());             //proxy ( class hellojpa.Member$HibernateProxy$YO93aEu4)

            Member findMember = em.find(Member.class, member1.getId());     // 프록시가 초기화 된다.
            System.out.println("reference.getClass() = " + findMember.getClass()); class hellojpa.Member$HibernateProxy$YO93aEu4
            System.out.println("a == a" + (refMember == findMember));       // true
```
> 해석
```
// 프록시가 초기화 됨에도 불구하고 둘다 프록시로 반환이 된다.
// 즉 프록시로 한번 조회가 되면 이후로는 프록시의 참조를 통해 엔티티조회를 하는것이다.
// 결국 프록시든 엔티티는 개발에는 문제가 없도록 작업되도록 JPA가 작동한다.
```
+ 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)
```java
//            ==================== 준영속 상태일때
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("refMember = " + refMember.getClass());             //proxy생성
            
//            =================준영속상태로 만드는 작업들===========
            em.detach(refMember); // 영속성컨테이너에서 제외
//            em.close();
//            em.clear();

            System.out.println("refMember = " + refMember.getUsername()); // 초기화작업
```
> 해석
```
catch문에 e.printStackTrace(); 추가해서 예외 출력문을 봐보자.
LazyInitializationException : could not initialize proxy 가 뜬다.
준영속상태이기 때문에 영속성 컨텍스트의 도움을 받지 못하므로 값을 가져오지 못한다.(실무에서 매우 많이 일어남)
```

## 프록시 확인
> 위의 준영속 상태로 만드는 코드들을 지우고 초기화를 해보고, 안해보면서 확인해보자.
+ 프록시 인스턴스의 초기화 여부 확인
PersistenceUnitUtil.isLoaded(Object entity) 
```
System.out.println("isLoaded = "+ emf.getPersistenceUnitUtil().isLoaded(refMember));  // boolean 결과
```
+ 프록시 클래스 확인 방법
entity.getClass().getName() 출력(이전 코드들에서 작업한 것과 같다)
+ 프록시 강제 초기화
org.hibernate.Hibernate.initialize(entity); 
```
Hibernate.initialize(refMember); // 강제 초기화
```
+ 참고: JPA 표준은 강제 초기화 없으므로, 강제로 DB에서 호출하도록 member.getName() 을 사용하면 된다.
