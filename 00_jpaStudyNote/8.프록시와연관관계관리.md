## 왜쓰는걸까?
```java
public void printUserAndTeam(String memberId) {
   Member member = em.find(Member.class, memberId);
   Team team = member.getTeam();
   System.out.println("회원 이름: " + member.getUsername()); 
   System.out.println("소속팀: " + team.getName()); 
}
```
+ 회원과 팀을 함께 출력할때는 find메서드로 Member 엔티티속 team을 이용하여 (MEMBER, TEAM)을 join한 쿼리를 통해 값을 가져오면 될것이다.

```java
public void printUser(String memberId) {
 Member member = em.find(Member.class, memberId);
 Team team = member.getTeam();
 System.out.println("회원 이름: " + member.getUsername());  // 영속성 컨텍스트에 존재하는 MEMBER에서 조회 가능함.
}
```
+ 그러나 만약 회원만 출력하고 싶다면, 굳이 Team객체와, DB에서 TEAM 테이블을 join 하는 쿼리가 필요할까?
+ 오히려 굳이 DB에서 여러 자원을 꺼내오므로, 자원의 낭비일 것이다.
+ 이 문제를 해결하기 위해서는 즉시 로딩와 지연로딩을 알면되지만, 이 로딩이 동작하는 방식을 이해하기 위해 먼저 프록시에대해 알아보자.

# 1.프록시

## 프록시 기초
- em.find() vs em.getReference() 
- em.find(): 데이터베이스를 통해서 **실제 엔티티 객체** 조회
- em.getReference(): 데이터베이스 조회를 미루는 **가짜(프록시)를 생성하고, 필요시 엔티티 객체 조회**
+ 그림1
```java
            Member member = new Member();
            member.setUsername("hello");

            em.persist(member);

            em.flush(); // 커밋전에 쿼리를 출력한다.
            em.clear();

//            Member findMember = em.find(Member.class, member.getId());
            Member findMember = em.getReference(Member.class, member.getId());              // find 대신 getReference

//            System.out.println("findMember.getId() = " + findMember.getId());             // 쿼리 생성x 
//            System.out.println("findMember.getUsername() = " + findMember.getUsername()); // join 쿼리 생성
            System.out.println("findMember = " + findMember.getClass());                    // findMember = class hellojpa.Member$HibernateProxy$lVigPKrS
```
+ 위 코드의 getReference를 만들었을때는 프록시 껍데기만 만들었기때문에, 쿼리를 생성하지 않는다.
+ 우리가 getReference() 할때 id값을 넣어주었었다. 그러므로 id만 사용시에는 쿼리가 안나가고 영속성 컨텍스트에서 값을 조회한다.
+ Username을 사용할 시에는 DB에 있는 Username을 찾아오기 위해, DB에 쿼리를 날리고 프록시가 Member 엔티티의 값을 참조해온다.
(디테일하게는 아래 프록시 객체의 초기화를 참고하자)
+ getClass()로 프록시 주소를 알수 있다.

## 프록시 특징
+ 그림 2
+ 실제 클래스를 상속 받아서 만들어짐
+ 실제 클래스와 겉 모양이 같다. 
+ 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상-JPA가 그렇게 구현해 두었다.) 
****
+그림 3
+ 프록시 객체는 실제 객체의 참조(target)를 보관
+ 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

## 프록시 객체의 초기화
+ 그림 4
+ MemberProxy에 target에 Name값이 없으므로 초기화를 요청한다.
+ 이후 DB에서 조회해와서(select 쿼리가 생성), 참조변수 target이 Member 엔티티를 가리키도록 만든다.
+ 한번 초기화하면 이제 target참조변수에서 엔티티를 가리키고 있기때문에 추가로 초기화 하지않아도 된다.

## 프록시의 특징 심화
+ 프록시 객체는 처음 사용할 때 한 번만 초기화
```
(위 코드에서 추가작업...)
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리생성
System.out.println("findMember.getUsername() = " + findMember.getUsername()); // 쿼리를 생성하지않음.
==========================================================
 - 두번 사용해도 한번만 초기화하면 프록시의 참조로 영속성 컨텍스트에 존재하는 원본 엔티티에서 값을 찾아올 수 있다.
```
+ 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
```
System.out.println("beforefindMember = " + findMember.getClass());    // beforefindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
System.out.println("findMember.getUsername() = " + findMember.getUsername());
System.out.println("afterfindMember = " + findMember.getClass());     // afteffindMember = class hellojpa.Member$HibernateProxy$AmXvHDtI
==============================================
 - 초기화 전, 후 같은 프록시 값을 가지고 있다.
```
+ 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용) 
```
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("member2");
            em.persist(member2);

            em.flush();
            em.clear();
// -------------------------1. 두 참조변수가 find로 엔티티를 조회했을 경우
//            Member m1 = em.find(Member.class, member1.getId());
//            Member m2 = em.find(Member.class, member2.getId());
//            System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // 같은 엔티티이므로 같은타입이다.

// -------------------------2. 참조변수가 각각의 엔티티, 프록시를 조회했을 경우
            Member m1 = em.find(Member.class, member1.getId());           // 엔티티객체를 의미
            Member m2 = em.getReference(Member.class, member2.getId());   // 프록시를 의미
            logic(m1,m2);
======================================================
    private static void logic(Member m1, Member m2) {
        // System.out.println("m1 == m2 : " + (m1.getClass() == m2.getClass())); // (false)다른타입이다.(객체와 프록시)
        
        // m1, m2가프록시값이든, 객체값이든 일치
        System.out.println("m1 == m2 : " + (m1 instanceof Member)); // 이런식으로 비교가능(true)
        System.out.println("m1 == m2 : " + (m2 instanceof Member)); // 이런식으로 비교가능(true)
    }
```
+ 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다.
```java
// 선엔티티 후 프록시
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member m1 = em.find(Member.class, member1.getId());

            Member reference = em.getReference(Member.class, member1.getId());
            System.out.println("reference.getClass() = " + reference.getClass());  // reference.getClass() = class hellojpa.Member
            System.out.println("a == a" + (m1 == reference));  
            //reference가 프록시가 아닌 Member엔티티로 나온다.
```
> 근거
```
이유1 : 어차피 Member 원본이 1차 캐시(영속성 컨텍스트)에 등록되어있으므로 가져오기만하면 된다.
이유2 : JPA에서 한 트랜잭션안의 영속성 컨텍스트는 m1이 객체든 프록시든 일치하게 만들도록 작동한다.
       (여러 참조변수로 자바 컬렉션 안쪽 같은 객체를 참조하면, 두 참조변수는 일치하는 로직을 가지는 것과 비슷하다.)
================================================================================================================================================
만약 위 참조변수 m1과 reference가 둘다 em.getReference()로 프록시를 가지고 있다면 어떻게 될까?
JPA 로직에 따라 둘다 프록시 Class를 가지며, 영속성컨텍스트에서 == 관계를 가진다.
================================================================================================================================================
```
+ 만약 반대순서로 프록시가 먼저 만들어지고 초기화를 작업하면 어떻게 될까?
```java
// 선프록시 , 후엔티티
 Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("m1 = " + refMember.getClass());             //proxy ( class hellojpa.Member$HibernateProxy$YO93aEu4)

            Member findMember = em.find(Member.class, member1.getId());     // 프록시가 초기화 된다.
            System.out.println("reference.getClass() = " + findMember.getClass()); class hellojpa.Member$HibernateProxy$YO93aEu4
            System.out.println("a == a" + (refMember == findMember));       // true
```
> 해석
```
// 프록시가 초기화 됨에도 불구하고 둘다 프록시로 반환이 된다.
// 즉 프록시로 한번 조회가 되면 이후로는 프록시의 참조를 통해 엔티티조회를 하는것이다.
// 결국 프록시든 엔티티는 개발에는 문제가 없도록 작업되도록 JPA가 작동한다.
```
+ 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)
```java
//            ==================== 준영속 상태일때
            Member member1 = new Member();
            member1.setUsername("member1");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("refMember = " + refMember.getClass());             //proxy생성
            
//            =================준영속상태로 만드는 작업들===========
            em.detach(refMember); // 영속성컨테이너에서 제외
//            em.close();
//            em.clear();

            System.out.println("refMember = " + refMember.getUsername()); // 초기화작업
```
> 해석
```
catch문에 e.printStackTrace(); 추가해서 예외 출력문을 봐보자.
LazyInitializationException : could not initialize proxy 가 뜬다.
준영속상태이기 때문에 영속성 컨텍스트의 도움을 받지 못하므로 값을 가져오지 못한다.(실무에서 매우 많이 일어남)
```

## 프록시 확인
> 위의 준영속 상태로 만드는 코드들을 지우고 초기화를 해보고, 안해보면서 확인해보자.
+ 프록시 인스턴스의 초기화 여부 확인
PersistenceUnitUtil.isLoaded(Object entity) 
```
System.out.println("isLoaded = "+ emf.getPersistenceUnitUtil().isLoaded(refMember));  // boolean 결과
```
+ 프록시 클래스 확인 방법
entity.getClass().getName() 출력(이전 코드들에서 작업한 것과 같다)
+ 프록시 강제 초기화
org.hibernate.Hibernate.initialize(entity); 
```
Hibernate.initialize(refMember); // 강제 초기화
```
+ 참고: JPA 표준은 강제 초기화 없으므로, 강제로 DB에서 호출하도록 member.getName() 을 사용하면 된다.

# 2. 즉시로딩과 지연로딩
+ 맨처음의 문제를 다시 고민해보자. Member를 조회할 때 Team도 함께 조회해야 할까? 말아야할까?
+ 이 문제는 즉시로딩과 지연로딩으로 해결 할 수 있다.

### 지연로딩 LAZY
+ 전체 APP중에 Member를 조회할때는 Member만 쓰고 Team을 동시에 조회시키지 않고 싶다면 지연로딩을 사용한다.
```java
@Entity
public class Member extends BaseEntity {
     ....
     
    @ManyToOne(fetch = FetchType.LAZY) // 지연로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```
> 코드작업
```JAVA
Team team = new Team();
            team.setName("teamA");
            em.persist(team);

            Member member1 = new Member();
            member1.setUsername("member1");
            member1.setTeam(team);
            em.persist(member1);

            em.flush();
            em.clear();

            Member m = em.find(Member.class, member1.getId()); // 쿼리를 보면 member쿼리만 조회해온다.
           
            System.out.println("m = " + m.getTeam().getClass()); //Team 추가후에 Team의 프록시가 나오는 모습확인

            System.out.println("==============");
            System.out.println("teamName = "+m.getTeam().getName());      //  Team의 속성을 사용하는 시점에, 프록시가 초기화하여 Team의 쿼리를 가져온다.
            System.out.println("==============");
```
> 결과 콘솔창 
```
    select
        member0_.MEMBER_ID as member_i1_3_0_,
        member0_.INSERT_MEMBER as insert_m2_3_0_,
        member0_.createdDate as createdd3_3_0_,
        member0_.lastModifiedBy as lastmodi4_3_0_,
        member0_.lastModifiedDate as lastmodi5_3_0_,
        member0_.TEAM_ID as team_id7_3_0_,
        member0_.USERNAME as username6_3_0_ 
    from
        Member member0_ 
    where
        member0_.MEMBER_ID=?
m = class hellojpa.Team$HibernateProxy$sx7qMf9G
==============
Hibernate: 
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
teamName = teamA
==============
```
+ 그림5
+ 지연로딩 LAZY을 사용해서 프록시로 조회한다.
+ 사용시점에 초기화한다.

### 즉시 로딩
```
@Entity
public class Member extends BaseEntity {
     ....
     
    @ManyToOne(fetch = FetchType.EAGER) // 즉시로딩으로 설정
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```
> 콘솔결과창( 이전과 실행코드는 동일하다)
```
    select
        member0_.MEMBER_ID as member_i1_3_0_,
        member0_.INSERT_MEMBER as insert_m2_3_0_,
        member0_.createdDate as createdd3_3_0_,
        member0_.lastModifiedBy as lastmodi4_3_0_,
        member0_.lastModifiedDate as lastmodi5_3_0_,
        member0_.TEAM_ID as team_id7_3_0_,
        member0_.USERNAME as username6_3_0_,
        team1_.TEAM_ID as team_id1_7_1_,
        team1_.INSERT_MEMBER as insert_m2_7_1_,
        team1_.createdDate as createdd3_7_1_,
        team1_.lastModifiedBy as lastmodi4_7_1_,
        team1_.lastModifiedDate as lastmodi5_7_1_,
        team1_.name as name6_7_1_ 
    from
        Member member0_ 
    left outer join
        Team team1_ 
            on member0_.TEAM_ID=team1_.TEAM_ID 
    where
        member0_.MEMBER_ID=?
m = class hellojpa.Team                                       // 프록시가 아닌 엔티티를 가져온다.
==============
teamName = teamA
==============
```
+ Member와 Team을 Join해서 select 해오는 모습을 볼 수 있다.
+ 프록시와 초기화가 필요가 없다. 그냥 엔티티객체를 가져온다.
+ 만약 수십개의 엔티티들이 서로 연결되어 있다면 Join을 여러번 하게되므로 DB 성능상에 문제가 발생할 것이다.
+ 그림6
### 프록시와 즉시로딩 주의
+ 가급적 지연 로딩만 사용(특히 실무에서) 
+ 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
+ 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. 
```java
            Team team = new Team();
            team.setName("teamA");
            em.persist(team);

            Team teamB = new Team();
            team.setName("teamB");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("member1");
            member1.setTeam(team);
            em.persist(member1);

            // N+1을 위해 추가
            Member member2 = new Member();
            member2.setUsername("member2");
            member2.setTeam(teamB);
            em.persist(member2);

            em.flush();
            em.clear();
            
            // JPQL
            List<Member> members = em.createQuery("select m from Member m", Member.class)
                                        .getResultList();
```
> 콘솔결과
```
    /* select
        m 
    from
        Member m */ select
            member0_.MEMBER_ID as member_i1_3_,
            member0_.INSERT_MEMBER as insert_m2_3_,
            member0_.createdDate as createdd3_3_,
            member0_.lastModifiedBy as lastmodi4_3_,
            member0_.lastModifiedDate as lastmodi5_3_,
            member0_.TEAM_ID as team_id7_3_,
            member0_.USERNAME as username6_3_ 
        from
            Member member0_
Hibernate:                                            // teamA
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
Hibernate:                                               // teamB
    select
        team0_.TEAM_ID as team_id1_7_0_,
        team0_.INSERT_MEMBER as insert_m2_7_0_,
        team0_.createdDate as createdd3_7_0_,
        team0_.lastModifiedBy as lastmodi4_7_0_,
        team0_.lastModifiedDate as lastmodi5_7_0_,
        team0_.name as name6_7_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
```
> N+1 문제
```
- 현재 member1 : TeamA , member2 : TeamB 상황이다.
- JPQL은 쿼리를 해석한대로 Member를 가져온다. 그런데 Team과 Member는 즉시로딩인 상태이다.
- 그러므로 member1, member2에 해당하는 Team들을 쿼리로 가져온다. 
- 이렇게 1개의 쿼리(Member)를 추가했는데, N개(teamA,teamB)의 쿼리가 추가되는 문제를 N+1 문제라고한다.
- 이 문제는 DB성능을 떨어트릴 위험이 매우 높다.
```
+ @ManyToOne, @OneToOne은 defalut가 즉시 로딩이다. -> LAZY로 설정해주자.
+ @OneToMany, @ManyToMany는 default가 지연 로딩이다.

### 지연 로딩 활용
그림 7
+ Member와 Team은 자주 함께 사용 -> 즉시 로딩
+ Member와 Order는 가끔 사용 -> 지연 로딩
+ Order와 Product는 자주 함께 사용 -> 즉시 로딩

### 실무
+ 모든 연관관계에 지연 로딩을 사용해라! 
+ 실무에서 즉시 로딩을 사용하지 마라! 
+ JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!(뒤에서 설명) 
```
List<Member> members = em.createQuery("select m from Member m join fetch m.team", Member.class)
                                       .getResultList();
===========================================================================================================================
위처럼 수정하면 fetchjoin을 사용할 수 있다.
 - N+1문제는 Lazy(지연로딩)으로 설정하고 fetchjoin을 설정하면 해결할 수 있다.
 실무에서는 위작업은 한번에 Member 에 필요한 team의 값들이 다들어간 쿼리를 만들어 조회할수 있다.
===========================================================================================================================
    /* select
        m 
    from
        Member m 
    join
        fetch m.team */ select
            member0_.MEMBER_ID as member_i1_3_0_,
            team1_.TEAM_ID as team_id1_7_1_,
            member0_.INSERT_MEMBER as insert_m2_3_0_,
            member0_.createdDate as createdd3_3_0_,
            member0_.lastModifiedBy as lastmodi4_3_0_,
            member0_.lastModifiedDate as lastmodi5_3_0_,
            member0_.TEAM_ID as team_id7_3_0_,
            member0_.USERNAME as username6_3_0_,
            team1_.INSERT_MEMBER as insert_m2_7_1_,
            team1_.createdDate as createdd3_7_1_,
            team1_.lastModifiedBy as lastmodi4_7_1_,
            team1_.lastModifiedDate as lastmodi5_7_1_,
            team1_.name as name6_7_1_ 
        from
            Member member0_ 
        inner join
            Team team1_ 
                on member0_.TEAM_ID=team1_.TEAM_ID
```
+ 즉시 로딩은 상상하지 못한 쿼리가 나가는 위험이 매우 높다.
