# 1. 소개

## JPA는 다양한 쿼리 방법을 지원
+ JPQL 
+ JPA Criteria 
+ QueryDSL 
+ 네이티브 SQL 
+ JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께사용

## JPQL 소개
+ 이전까지는 가장 단순한 조회방법으로 em.find() 또는 member.get().get() 등으로 조회했었다.
+ 만약 "나이가 18이상인 회원을 모두 검색하고 싶다면"? 이라는 조건이 있을때 JPQL을 사용할 수 있다.
### 특징
+ 지금까지 JPA를 사용하면서 우리는 엔티티 객체를 중심으로 개발해왔다.
+ 그러므로 검색 쿼리에서 검색을 할 때 **테이블이 아닌 엔티티 객체**를 대상으로 검색하고 싶다.
+ 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능하므로 애플리케이션이 필요한 데이터만 DB에서 불러오면서, 검색 조건이 포함시킬수 있는 SQL이 필요하다.
****
+ JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공한다.
+ SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원(ANSI 방식)
+ **JPQL은 엔티티 객체를 대상으로 쿼리**
+ SQL은 데이터베이스 테이블을 대상으로 쿼리
> jpaMain
```
            List<Member> resultList = em.createQuery("select m From Member m where m.username like '%kim%'", Member.class)
                    .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    From
        Member m 
    where
        m.username like '%kim%' */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.USERNAME as username5_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME like '%kim%'
```
+ 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
+ SQL을 추상화해서 특정 데이터베이스 SQL에 의존X ( JPA가 DB 방언에 맞추어 쿼리문을 날려준다.)
+ JPQL을 한마디로 정의하면 객체 지향 SQL


## Criteria 소개
> JPQL 동적쿼리
```
            String qlString = "select m From Member m";
            String username;
            if(username != null){
                String where = " where m.username like '%kim%'";
                sqlquery = qlString + where;
                em.createQuery(sqlquery);
            }
```
+ (위 코드는 의사코드로 생각하자)JPQL은 조건에 따라 쿼리를 다르게 만드는 동적쿼리 작성에 있어서 문자열로 처리해야하기때문에 복잡하고 어렵다.
> criteria 코드작성
```java
            // ----------------------------그 대안으로 criteria가 탄생하였다.
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Member>  query = cb.createQuery(Member.class);

            Root<Member> m = query.from(Member.class);      // 쿼리를 지금 자바코드에서 짜고있는 모습이다.

            CriteriaQuery<Member> cq =  query.select(m);
            String username = "kimkyu";
            if(username != null){
                cq = cq.where(cb.equal(m.get("username"),"kim"));
            }
            List<Member> resultList = em.createQuery(cq)
                    .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        generatedAlias0 
    from
        Member as generatedAlias0 
    where
        generatedAlias0.username=:param0 */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.USERNAME as username5_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME=?
```
+ 문자가 아닌 자바코드로 JPQL을 작성할 수 있음. 그러므로 컴파일 에러로 발견뿐만아니라, 동적쿼리도 해결할 수 있다.
+ JPQL 빌더 역할을 하며 JPA 공식 기능이다.
+ 단점: sql스럽지 않다. 그러므로 복잡하고 실용성이 없다. 
+ Criteria 대신에 QueryDSL 사용 권장

## QueryDSL
> QueryDSL 예시코드
```java
 //JPQL 
 //select m from Member m where m.age > 18
 JPAFactoryQuery query = new JPAQueryFactory(em);
 QMember m = QMember.member;
 
 List<Member> list = 
     query.selectFrom(m)
     .where(m.age.gt(18)) 
     .orderBy(m.name.desc())
     .fetch();
```
+ (위 코드는 실행시킬수 없는 예시를 위해 적은코드이다.)
+ 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
+ JPQL 빌더 역할
+ 컴파일 시점에 문법 오류를 찾을 수 있으며 동적쿼리 작성 편리함
+ 단순하고 쉬움
+ 실무 사용 권장
+ JPQL 동작 방식만 잘 이해한다면, QueryDSL 공식사이트를 보고도 충분히 사용하기 쉽다.

## 네이티브 SQL
+ JPA가 제공하는 SQL을 직접 사용하는 기능
+ JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능을 구현시킬 수 있다.
+ 예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트
> jpaMain
```
            // -----------------------------------native query 소개
            // 실제 테이블에서 query를 날린다.
            em.createNativeQuery("select MEMBER_ID, city, street, zipcode, USERNAME FROM MEMBER")
                            .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* dynamic native SQL query */ select
        MEMBER_ID,
        city,
        street,
        zipcode,
        USERNAME 
    FROM
        MEMBER
```

## JDBC 직접사용 또는 SpringJdbcTemplate
+ JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능하다.
+ 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요하다.
• 예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시를 해주어야한다.
```
 - 이전까지 JPQL이나 Native query 에서 createquery()를 하면 내부의 flush()가 호출되어 쿼리를 낸다.
   즉 DB테이블 에서 값을 가져온후 엔티티에 값이 들어간 상태였다.
 - 그러나 JDBC 직접사용하거나 SpringJdbcTemplate 경우 메서드 내부에 flush()가 속해있지않다.
            em.flush();
            dbconn.executeQuery("select * from member");    // 예시
 - 그러므로 위 처럼 flush() 후 값이 들어온 Member 객체에 대하여 쿼리를 작성해야한다.
```

# 2.JPQL 기본 문법과 기능
+ **(Java Persistence Query Language)**
## JPQL 소개
+ JPQL은 객체지향 쿼리 언어다.따라서 테이블을 대상으로 쿼리하는 것이 아니라 **엔티티 객체를 대상**으로 쿼리한다. 
+ JPQL은 SQL을 추상화해서 특정데이터베이스 SQL에 의존하지 않는다. 
+ JPQL은 결국 SQL로 변환된다
+그림1
+ 앞으로의 작업은 hellojpa project - jpql 패키지 아래에서 작업된다.

## JPQL 문법
```
select_문 :: = 
             select_절
             from_절
             [where_절] 
             [groupby_절] 
             [having_절] 
             [orderby_절] 
update_문 :: = update_절 [where_절] 
delete_문 :: = delete_절 [where_절]
```
+ "select m from Member as m where m.age > 18" 
+ 엔티티와 속성은 대소문자 구분O (Member, age) - 마치 자바에서 구분하는 것과 같다.
+ JPQL 키워드는 대소문자 구분X (SELECT, FROM, where) 
+ 엔티티 이름 사용, 테이블 이름이 아님(Member) 
+ **별칭은 필수(m)** (as는 생략가능)

## 집합과 정렬
```sql
select
 COUNT(m), //회원수
 SUM(m.age), //나이 합
 AVG(m.age), //평균 나이
 MAX(m.age), //최대 나이
 MIN(m.age) //최소 나이
from Member m

===========
 GROUP BY, HAVING 
 ORDER BY
```
+ sql에서 기본적으로 제공하는 기능은 다 제공하고 있다.

## TypeQuery, Query
+ TypeQuery: 반환 타입이 명확할 때 사용
+ Query: 반환 타입이 명확하지 않을 때 사용
```java
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            TypedQuery<Member> query1 = em.createQuery("select m from Member m", Member.class);// Member.class로 타입정보를 줄수 있다
            TypedQuery<String> query2 = em.createQuery("select m.username from Member m", String.class);
            
            // username과 age는 서로 타입이 다르므로 타입을 정해줄수 없음. 이때는 Query 사용
            Query query3 = em.createQuery("select m.username, m.age from Member m");
```

## 결과 조회API
+ query.getResultList(): 결과가 하나 이상일 때, 리스트 반환
  - 결과가 없으면 빈 리스트 반환
+ query.getSingleResult(): 결과가 **정확히 하나**, 단일 객체 반환
  - 결과가 없으면: javax.persistence.NoResultException 
  - 둘 이상이면: javax.persistence.NonUniqueResultException
```java
            // getResultList
            TypedQuery<Member> query1 = em.createQuery("select m from Member m", Member.class);
            List<Member> resultList = query1.getResultList();    // 반환 타입이 List
           
            for (Member member1 : resultList) {
                System.out.println("member1 = "+ member1);
            }

            //getSingleResult
            // 1개만을 반환하므로 반환타입이 Member
            Member singleResult = query1.getSingleResult();
            System.out.println("singleResult = " + singleResult);
```
+ getSingleResult 메서드에서 값이 안뜨면 **예외가 발생하는 문제**에 대해 불편하다는 논란이 많다.
+ Spring Data JPA -> try catch를 씌워놓은 getSingleResult를 호출시켜 Optional값 또는 Null이 나옴.

## 파라미터 바인딩 - 이름기준, 위치기준
```java
        // 파라미터 바인딩
        Member result = em.createQuery("select m from Member m where m.username = :username", Member.class)
                        .setParameter("username","member1")
                        .getSingleResult();
            System.out.println("result = " + result.getUsername());
            // 바인딩한 값은 쿼리에 '?'로 나오며, 파라미터 바인딩이 성공함.
```
+ 위치기준은 나중에 오류가 발생하였을때 위치가 밀려 에러의 원인을 찾기 힘들 수도 있다.
+ 그러므로 명확한 **이름기준으로 쓰는게 좋다.**
> 위치기준 파라미터 바인딩
```
SELECT m FROM Member m where m.username=?1 
query.setParameter(1, usernameParam);
```

# 3. 프로젝션
+ SELECT 절에 조회할 대상을 지정하는 것
+ 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입) 
+ SELECT m FROM Member m -> 엔티티 프로젝션
+ SELECT m.team FROM Member m -> 엔티티 프로젝션2
+ SELECT m.address FROM Member m -> 임베디드 타입 프로젝션
+ SELECT m.username, m.age FROM Member m -> 스칼라 타입 프로젝션
+ DISTINCT로 중복 제거 가능
```java
Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush();
            em.clear();
==================================================
            List<Member> result = em.createQuery("select m from Member", Member.class)
                                        .getResultList();
            Member findMember = result.get(0);
            findMember.setAge(20);       // 값이 바뀐다. 즉 영속성컨테이너에서 관리한다는 의미이다.
==================================================
//엔티티프로젝션2
            List<Team> result = em.createQuery("select m.team from Member m", Team.class)
                    .getResultList();
            List<Team> result2 = em.createQuery("select m.team from Member m join m.team", Team.class)
                    .getResultList();
            //result 와 result2는 같은 의미의 소스코드이다.
            (즉 DB입장에서는 team을 찾아오는 과정에서 묵시적 join이 일어나야함)
==================================================
// 임베디드타입
            List<Address> result = em.createQuery("select o.address from Order o", Address.class)
                    .getResultList();
            // 어찌됬든 값타입이므로 o.address(엔티티.클래스) 로 지정해주어야한다.
==================================================
//스칼라타입 프로젝션
            List<Team> result = em.createQuery("select distinct m.username, m.age from Member m")
                    .getResultList();
```
### 여러 값 조회
+ 1.Query 타입으로 조회
```java
TypedQuery<String> query2 = em.createQuery("select m.username from Member m", String.class);
```
+ 2.Object[] 타입으로 조회
```
            List resultList = em.createQuery("select m.username, m.age from Member m")
                    .getResultList();

            Object o = resultList.get(0);                   // Object[] 형태로 출력된다.
            Object[] result = (Object[])o;                  // 그러므로 Object[]로 형변환 해준다.
            System.out.println("username = " + result[0]);  //member1
            System.out.println("age = " + result[1]);       //10
            
//=================================================================================================            
            List<Object[]> resultList2 = em.createQuery("select m.username, m.age from Member m")
                    .getResultList();  // 사실은 이렇게 List<Object[]> 타입으로 나온다.
            Object[] o = resultList2.get(0);
            System.out.println("username = " + resultList2[0]);  //member1
            System.out.println("age = " + resultList2[1]);       //10
```
+ 3.new 명령어로 조회
   - 단순 값을 DTO로 바로 조회
   - 패키지 명을 포함한 전체 클래스 명 입력
   - 순서와 타입이 일치하는 생성자 필요

> 코드확인
```java
//DTO 클래스 생성
public class MemberDTO {
    private String username;
    private int age;
    
    public MemberDTO(String username, int age) {
        this.username = username;
        this.age = age;
    } 
//jpaMain==========================================================    
            // 패키지명을 포함한 클래스명을 써야한다.
            List<MemberDTO> resultList3 = em.createQuery("select new jpql.MemberDTO(m.username, m.age) from Member m", MemberDTO.class)
                    .getResultList();
            MemberDTO memberDTO = resultList3.get(0);
            System.out.println("memberDTO.getUsername() = " + memberDTO.getUsername());
            System.out.println("memberDTO.getAge() = " + memberDTO.getAge());
```

# 4.페이징API
+ JPA는 페이징을 다음 두 API로 추상화
+ setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작) 
+ setMaxResults(int maxResult) : 조회할 데이터 수
>JpaMain
```java
for(int i = 0; i < 100; i++){
                Member member = new Member();
                member.setUsername("member" + i);
                member.setAge(i);
                em.persist(member);
            }

            em.flush();
            em.clear();

            // 제대로 페이징 되는지 확인을 위해 order by로 정렬후 진행
            List<Member> result = em.createQuery("select m from Member m order by m.age desc",Member.class)
                    .setFirstResult(1)
                    .setMaxResults(10)
                    .getResultList();

            System.out.println("result.size = "+ result.size());
            for (Member member1 : result) {
                System.out.println("member1 = "+ member1);
            }
```
> 결과쿼리
```sql
Hibernate: 
    /* select
        m 
    from
        Member m 
    order by
        m.age desc */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as team_id4_0_,
            member0_.username as username3_0_ 
        from
            Member member0_ 
        order by
            member0_.age desc limit ? offset ?
result.size = 10
member1 = Member{id=99, username='member98', age=98}
member1 = Member{id=98, username='member97', age=97}
member1 = Member{id=97, username='member96', age=96}
member1 = Member{id=96, username='member95', age=95}
member1 = Member{id=95, username='member94', age=94}
member1 = Member{id=94, username='member93', age=93}
member1 = Member{id=93, username='member92', age=92}
member1 = Member{id=92, username='member91', age=91}
member1 = Member{id=91, username='member90', age=90}
member1 = Member{id=90, username='member89', age=89}
```
+ 역순으로, 0 번째 위치는 건너뛰고 출력하므로 98~89까지 나온다.
+ limit ? offset ? : H2 DB의 페이징 하는 방언
> 페이징 API - MySQL 방언
```sql
SELECT
             M.ID AS ID,
             M.AGE AS AGE,
             M.TEAM_ID AS TEAM_ID,
             M.NAME AS NAME 
FROM
             MEMBER M 
ORDER BY
             M.NAME DESC LIMIT ?, ?
```
> 페이징 API - Oracle 방언
```sql
SELECT * FROM
             ( SELECT ROW_.*, ROWNUM ROWNUM_ 
             FROM
             ( SELECT
                         M.ID AS ID,
                         M.AGE AS AGE,
                         M.TEAM_ID AS TEAM_ID,
                         M.NAME AS NAME 
             FROM MEMBER M 
             ORDER BY M.NAME 
             ) ROW_ 
 WHERE ROWNUM <= ?
 ) 
WHERE ROWNUM_ > ?
```
