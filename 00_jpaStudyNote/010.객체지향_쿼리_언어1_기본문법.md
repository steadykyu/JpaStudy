# 1. 소개

## JPA는 다양한 쿼리 방법을 지원
+ JPQL 
+ JPA Criteria 
+ QueryDSL 
+ 네이티브 SQL 
+ JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께사용

## JPQL 소개
+ 이전까지는 가장 단순한 조회방법으로 em.find() 또는 member.get().get() 등으로 조회했었다.
+ 만약 "나이가 18이상인 회원을 모두 검색하고 싶다면"? 이라는 조건이 있을때 JPQL을 사용할 수 있다.
### 특징
+ 지금까지 JPA를 사용하면서 우리는 엔티티 객체를 중심으로 개발해왔다.
+ 그러므로 검색 쿼리에서 검색을 할 때 **테이블이 아닌 엔티티 객체**를 대상으로 검색하고 싶다.
+ 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능하므로 애플리케이션이 필요한 데이터만 DB에서 불러오면서, 검색 조건이 포함시킬수 있는 SQL이 필요하다.
****
+ JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공한다.
+ SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원(ANSI 방식)
+ **JPQL은 엔티티 객체를 대상으로 쿼리**
+ SQL은 데이터베이스 테이블을 대상으로 쿼리
> jpaMain
```
            List<Member> resultList = em.createQuery("select m From Member m where m.username like '%kim%'", Member.class)
                    .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        m 
    From
        Member m 
    where
        m.username like '%kim%' */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.USERNAME as username5_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME like '%kim%'
```
+ 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
+ SQL을 추상화해서 특정 데이터베이스 SQL에 의존X ( JPA가 DB 방언에 맞추어 쿼리문을 날려준다.)
+ JPQL을 한마디로 정의하면 객체 지향 SQL


## Criteria 소개
> JPQL 동적쿼리
```
            String qlString = "select m From Member m";
            String username;
            if(username != null){
                String where = " where m.username like '%kim%'";
                sqlquery = qlString + where;
                em.createQuery(sqlquery);
            }
```
+ (위 코드는 의사코드로 생각하자)JPQL은 조건에 따라 쿼리를 다르게 만드는 동적쿼리 작성에 있어서 문자열로 처리해야하기때문에 복잡하고 어렵다.
> criteria 코드작성
```java
            // ----------------------------그 대안으로 criteria가 탄생하였다.
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Member>  query = cb.createQuery(Member.class);

            Root<Member> m = query.from(Member.class);      // 쿼리를 지금 자바코드에서 짜고있는 모습이다.

            CriteriaQuery<Member> cq =  query.select(m);
            String username = "kimkyu";
            if(username != null){
                cq = cq.where(cb.equal(m.get("username"),"kim"));
            }
            List<Member> resultList = em.createQuery(cq)
                    .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* select
        generatedAlias0 
    from
        Member as generatedAlias0 
    where
        generatedAlias0.username=:param0 */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.USERNAME as username5_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME=?
```
+ 문자가 아닌 자바코드로 JPQL을 작성할 수 있음. 그러므로 컴파일 에러로 발견뿐만아니라, 동적쿼리도 해결할 수 있다.
+ JPQL 빌더 역할을 하며 JPA 공식 기능이다.
+ 단점: sql스럽지 않다. 그러므로 복잡하고 실용성이 없다. 
+ Criteria 대신에 QueryDSL 사용 권장

## QueryDSL
> QueryDSL 예시코드
```java
 //JPQL 
 //select m from Member m where m.age > 18
 JPAFactoryQuery query = new JPAQueryFactory(em);
 QMember m = QMember.member;
 
 List<Member> list = 
     query.selectFrom(m)
     .where(m.age.gt(18)) 
     .orderBy(m.name.desc())
     .fetch();
```
+ (위 코드는 실행시킬수 없는 예시를 위해 적은코드이다.)
+ 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
+ JPQL 빌더 역할
+ 컴파일 시점에 문법 오류를 찾을 수 있으며 동적쿼리 작성 편리함
+ 단순하고 쉬움
+ 실무 사용 권장
+ JPQL 동작 방식만 잘 이해한다면, QueryDSL 공식사이트를 보고도 충분히 사용하기 쉽다.

## 네이티브 SQL
+ JPA가 제공하는 SQL을 직접 사용하는 기능
+ JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능을 구현시킬 수 있다.
+ 예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트
> jpaMain
```
            // -----------------------------------native query 소개
            // 실제 테이블에서 query를 날린다.
            em.createNativeQuery("select MEMBER_ID, city, street, zipcode, USERNAME FROM MEMBER")
                            .getResultList();
```
> 결과 쿼리
```sql
Hibernate: 
    /* dynamic native SQL query */ select
        MEMBER_ID,
        city,
        street,
        zipcode,
        USERNAME 
    FROM
        MEMBER
```

## JDBC 직접사용 또는 SpringJdbcTemplate
+ JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능하다.
+ 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요하다.
• 예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시를 해주어야한다.
```
 - 이전까지 JPQL이나 Native query 에서 createquery()를 하면 내부의 flush()가 호출되어 쿼리를 낸다.
   즉 DB테이블 에서 값을 가져온후 엔티티에 값이 들어간 상태였다.
 - 그러나 JDBC 직접사용하거나 SpringJdbcTemplate 경우 메서드 내부에 flush()가 속해있지않다.
            em.flush();
            dbconn.executeQuery("select * from member");    // 예시
 - 그러므로 위 처럼 flush() 후 값이 들어온 Member 객체에 대하여 쿼리를 작성해야한다.
```
